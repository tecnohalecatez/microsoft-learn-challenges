# Desarrollo de soluciones para Microsoft Azure

1. Una empresa planea usar Azure Cache for Redis. La empresa planea usar módulos de Redis. Necesita recomendar un nivel de servicio de Azure Cache for Redis. ¿Qué nivel de servicio tiene que recomendar?
    - **Enterprise**

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de servicio de Azure Cache for Redis. Los módulos de Redis solo se admiten en el nivel de servicio Enterprise. Los niveles de servicio Básico, Estándar y Premium no admiten módulos de Redis.


2. Usted administra una instancia de Azure Cache for Redis. Necesita cargar datos a petición en la memoria caché desde una base de datos grande. ¿Qué patrón de arquitectura de aplicaciones debería usar?
    - **Caché de datos**

    Este elemento pone a prueba los conocimientos de los candidatos sobre el patrón de diseño de arquitectura de aplicaciones, que forma parte de la implementación del almacenamiento en caché para las soluciones. Las bases de datos suelen ser demasiado grandes para cargarse directamente en una memoria caché, por lo que es habitual usar el patrón de caché de datos. El almacén de sesiones se usa para almacenar información de sesión de usuarios en lugar de almacenar demasiados datos en una cookie que pueda afectar negativamente al rendimiento. Las transacciones distribuidas permiten que una serie de comandos se ejecuten en un almacén de datos de back-end como una sola operación. Mediante el uso de la caché de contenido, puede proporcionar acceso más rápido al contenido estático en comparación con los almacenes de datos de back-end. El almacén de sesiones, las transacciones distribuidas y la caché de contenido no se pueden usar para cargar datos a petición.


3. Usted administra Azure Cache for Redis mediante clases en el espacio de nombres .NET StackExchange.Redis. Debe recuperar una referencia de una base de datos de Redis mediante el método GetDatabase. ¿Qué debería que hacer en primer lugar?
    - **Crear un objeto ConnectionMultiplexer**

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo interactuar mediante programación con Azure Cache for Redis, que es una parte integral de la implementación de patrones de caché de aplicaciones seguros y optimizados, incluyendo el ajuste de tamaño de datos, las conexiones, el cifrado y la expiración. La creación de un objeto ConnectionMultiplexer es el primer paso necesario para recuperar una referencia a una base de datos de Redis mediante el método GetDatabase. Se requiere crear un objeto CdnManagementClient cuando se use el almacenamiento en caché de Azure Content Delivery Network, no Azure Cache for Redis. Llamar a un método StringSet permitirá administrar el contenido de una base de datos de Redis, lo que se producirá una vez que el objeto ConnectionMultiplexer y la base de datos se hayan creado. Llamar a un método StringGet permitirá recuperar el contenido de una base de datos de Redis, lo que se producirá una vez que el objeto ConnectionMultiplexer y la base de datos se hayan creado.


4. Tiene previsto usar Azure Cache for Redis como capa de almacenamiento en caché para varias aplicaciones. Tiene los siguientes requisitos: Evitar la pérdida de datos si los nodos están inactivos. Minimizar los costes de almacenamiento. Optimizar el rendimiento. ¿Qué solución debe usar?
    - **Persistencia de la base de datos de Redis (RDB) con la característica de eliminación temporal deshabilitada en la cuenta de almacenamiento asociada**

    Este elemento pone a prueba los conocimientos de los candidatos sobre la persistencia de datos en Azure Cache for Redis. La persistencia de RDB guarda copias de seguridad en función del intervalo de copia de seguridad configurado con un efecto mínimo en el rendimiento. Deshabilitar la característica de eliminación temporal en una cuenta de almacenamiento implica que Azure Cache for Redis no puede minimizar los costes de almacenamiento mediante la eliminación de los datos de copia de seguridad antiguos. Habilitar la característica de eliminación temporal en una cuenta de almacenamiento implica que Azure Cache for Redis no puede minimizar los costes de almacenamiento mediante la eliminación de los datos de copia de seguridad antiguos. La persistencia de AOF guarda cada escritura en un registro, lo que tiene un efecto significativo en el rendimiento. Deshabilitar y habilitar la característica de eliminación temporal en una cuenta de almacenamiento implica que Azure Cache for Redis no puede minimizar los costes de almacenamiento mediante la eliminación de los datos de copia de seguridad antiguos.


5. Tiene la siguiente clase GameStat:
    ```java
    public class GameStat
    {
        public string Id { get; set; }
        public string Sport { get; set; }
        public DateTimeOffset DatePlayed { get; set; }
        public string Game { get; set; }
        public IReadOnlyList<string> Teams { get; set; }
        public IReadOnlyList<(string team, int score)> Results { get; set; }

        public GameStat(string sport, DateTimeOffset datePlayed, string game, string[] teams, IEnumerable<(string team, int score)> results)
        {
            Id = Guid.NewGuid().ToString();
            Sport = sport;
            DatePlayed = datePlayed;
            Game = game;
            Teams = teams.ToList();
            Results = results.ToList();
        }

        public override string ToString()
        {
            return $"{Sport} {Game} played on {DatePlayed.Date.ToShortDateString()} - " +
                $"{String.Join(',', Teams)}\r\n\t" + 
                $"{String.Join('\t', Results.Select(r => $"{r.team } - {r.score}\r\n"))}";
        }
    }
    ```
    Debe almacenar una instancia de la clase GameStat en Azure Cache for Redis. ¿Qué dos segmentos de código debería usar? Cada respuesta correcta presenta una solución completa.

    - 
    ```java
    var stat = new GameStat("Soccer", new DateTime(2019, 7, 16), "Local Game", new[] { "Team 1", "Team 2" }, new[] { ("Team 1", 2), ("Team 2", 1) }); string serializedValue = System.Text.Json.JsonSerializer.Serialize (stat); bool added = db.StringSet("event:1950-world-cup", serializedValue);
    ```

    - 
    ```java
    var stat = new GameStat("Soccer", new DateTime(2019, 7, 16), "Local Game", new[] { "Team 1", "Team 2" }, new[] { ("Team 1", 2), ("Team 2", 1) }); bool added = db.StringSet("event:1950-world-cup", stat.ToString());
    ```

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo implementar el almacenamiento en caché. Los segmentos de código que incluyen la operación StringSet serializarán y almacenarán correctamente el contenido de la clase GameStat en Azure Cache for Redis. Los segmentos de código que incluyen la operación StringGet no lo harán.


6. Tiene una aplicación web de Azure que ocasionalmente experimenta tiempos de respuesta elevados. Debe recibir una notificación cuando el tiempo de respuesta supere un umbral determinado. ¿Qué tiene que hacer?
    - **Implemente alertas y pruebas web de Application Insights**

    Application Insights permite crear pruebas web que simulan interacciones de usuario con la aplicación y, a continuación, configuran alertas basadas en los resultados de estas pruebas. Las alertas de Resource Health de Azure Monitor se usan para la supervisión de la infraestructura, no para el rendimiento de las aplicaciones. Azure Service Health proporciona información sobre los problemas del servicio de Azure y el mantenimiento planeado, no sobre el rendimiento de las aplicaciones. Azure Advisor proporciona recomendaciones de procedimientos recomendados, no alertas de rendimiento de aplicaciones.


7. El equipo está desarrollando una nueva característica para una aplicación existente basada en Azure que depende en gran medida en el procesamiento de datos en tiempo real. La característica implica la integración de varios servicios de Azure y API de terceros. Debe crear una estrategia para asegurarse de que la integración de estos servicios no presenta ningún problema de rendimiento ni errores. Debe diseñar la solución de supervisión para detectar y solucionar posibles problemas. ¿Qué tiene que hacer?
    - **Use Live Metrics en Application Insights para observar la actividad de la aplicación implementada en tiempo real**

    La opción D es correcta porque Live Metrics proporciona observación en tiempo real de la actividad de la aplicación, lo que permite la detección inmediata y la respuesta a los problemas de rendimiento. La opción C es incorrecta, ya que es posible que las comprobaciones nocturnas no sean suficientes para las necesidades de procesamiento de datos en tiempo real. La opción A es incorrecta porque una sola prueba de disponibilidad no proporciona una supervisión completa de todos los servicios integrados. La opción B es incorrecta, ya que la revisión manual de los registros no es eficaz para la supervisión en tiempo real y puede retrasar la respuesta a los problemas.


8. Un equipo de desarrollo usa Application Insights para supervisar su aplicación web implementada en Azure. Han observado discrepancias en las métricas notificadas debido a un gran volumen de telemetría. Debe asegurarse de que las métricas notificadas reflejen con precisión el rendimiento de la aplicación sin verse afectados por el muestreo de telemetría. ¿Qué debería implementar para conseguir este objetivo?
    - **Configure Application Insights para usar métricas estándar agregadas previamente para paneles y alertas en tiempo real**

    Las métricas estándar agregadas previamente no se ven afectadas por el muestreo de telemetría y proporcionan datos precisos en tiempo real, lo que hace que sean adecuados para paneles y alertas. Aumentar la frecuencia de muestreo o deshabilitar el muestreo por completo aumentaría los costos y es posible que aún no proporcione métricas precisas debido al volumen de datos. La creación de una consulta de Kusto personalizada requeriría un esfuerzo manual y no soluciona el problema del muestreo que afecta a las métricas.


9. Tiene previsto usar Microsoft Graph para recuperar una lista de usuarios en un inquilino de Microsoft Entra ID. Es necesario optimizar los resultados de la consulta. ¿Qué dos opciones de consulta debería usar? Cada respuesta correcta presenta parte de la solución.
    - **$filter**
    - **$select**

    Este elemento pone a prueba los conocimientos de los candidatos sobre las opciones de consulta de Microsoft Graph La opción de consulta $filter debe usarse para limitar los resultados devueltos. La opción de consulta $select limita los atributos proyectados desde el conjunto de resultados, lo que hace que la consulta sea más eficaz. La opción de consulta $count está pensada para recuperar el recuento total de recursos coincidentes. La opción de consulta $expand se usa para recuperar recursos relacionados.


10. Tiene una cuenta de Azure Storage. Es necesario proporcionar a los usuarios externos la capacidad de crear y actualizar blobs. ¿Qué valor de enumeración de BlobSasPermissions debería usar?
    - **Escribir**

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo crear e implementar blobs. El permiso de escritura permitirá a los usuarios crear y actualizar blobs. El permiso Agregar solo es aplicable a blobs anexos. El permiso Crear solo permite a los usuarios crear blobs. No permite a los usuarios actualizar blobs. El permiso de lectura no permite a los usuarios crear y actualizar blobs.


11. Administra una aplicación web de Azure App Service denominada app1. App1 se registra como una aplicación multiinquilino en un inquilino de Microsoft Entra ID denominado tenant1. Debe conceder a app1 el permiso para acceder a Microsoft Graph API en tenant1.¿Qué entidad de servicio debería usar?
    - **application**

    Este elemento pone a prueba los conocimientos de los candidatos sobre el acceso a los datos de usuario desde Microsoft Graph, que forma parte de la implementación de la autenticación y autorización del usuario. Una aplicación de Microsoft Entra ID se define por su único objeto de aplicación, que reside en el inquilino de Microsoft Entra ID donde se registró la aplicación, (conocido como inquilino "principal" de la aplicación). La entidad de servicio de la aplicación se usa para configurar el permiso de app1 en tenant1 para acceder a Microsoft Graph API. La entidad de servicio heredada es una aplicación heredada (la que se ha creado antes de que se introdujeran o crearan registros de aplicaciones mediante experiencias heredadas). Las identidades administradas eliminan la necesidad de administrar las credenciales en el código. Solo hay una identidad administrada asignada por cada recurso y está asociada al ciclo de vida del recurso. Las identidades administradas para los recursos de Azure eliminan la necesidad de administrar las credenciales en el código. Una identidad administrada asignada por el usuario se puede crear y asignar a una o varias instancias de un servicio de Azure. La identidad administrada asignada por el usuario y la identidad administrada asignada por el sistema heredadas no se pueden usar para asignar permisos para app1 en tenant1 para acceder a Microsoft Graph API.


12. Desarrolla una aplicación. Un proveedor tendrá acceso a la aplicación. El proveedor requiere una firma de acceso compartido (SAS) para acceder a los servicios de Azure en su suscripción de la empresa. Debe proteger la SAS. ¿Qué tres acciones debe realizar? Cada respuesta correcta presenta una solución completa.
    - **Use siempre HTTPS**
    - **Use registros de Azure Monitor y Azure Storage para supervisar la aplicación**
    - **Defina una directiva de acceso almacenada para una SAS de servicio**

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo implementar firmas de acceso compartido (SAS). La recomendación de usar siempre HTTPS es válida y debería seguirse. Azure Monitor y el registro de Storage Analytics deberían usarse para observar cualquier pico en estos tipos de errores de autorización. Las directivas de acceso almacenadas le ofrecerán la posibilidad de revocar permisos para una SAS de servicio sin tener que volver a generar las claves de la cuenta de almacenamiento. Un procedimiento recomendado de seguridad es proporcionar al usuario los privilegios mínimos necesarios. Es mejor usar tiempos de expiración de corto plazo en servicios de SAS ad hoc o cuentas de SAS para que, incluso aunque una SAS estuviera en peligro, solo sería válida durante un tiempo breve.


13. Administra una aplicación registrada de Microsoft Entra ID denominada app1. App1 llama a una API web, que luego llamará a Microsoft Graph. Debe asegurarse de que la identidad del usuario que inició sesión se delegue a través de la cadena de solicitudes. ¿Qué flujo de autenticación debería usar?
    - **On-Behalf-Of**

    Este elemento pone a prueba los conocimientos de los candidatos sobre el acceso a los datos de usuario desde Microsoft Graph, que forma parte de la implementación de la autenticación y autorización del usuario. Flujo OAuth 2.0 On-Behalf-Of (OBO) se usa cuando una aplicación invoca un servicio o API web, que, a su vez, debe llamar a otro servicio o API web. La idea es propagar la identidad del usuario delegado y los permisos a través de la cadena de solicitudes. La concesión de un código de autorización de OAuth 2.0 se puede usar en aplicaciones que se instalan en un dispositivo para obtener acceso a recursos protegidos, como las API web. El flujo de concesión de credenciales de cliente de OAuth 2.0 permite que un servicio web (cliente confidencial) use sus propias credenciales para autenticarse al llamar a otro servicio web, en lugar de suplantar a un usuario. Implícito es un flujo basado en redirección. El cliente debe ser capaz de interactuar con el agente de usuario del propietario del recurso (normalmente un explorador web). El código de autorización, On-Behalf-Of e Implícito no se pueden usar para delegar el permiso y la identidad del usuario.


14. Desarrolla una aplicación web multiinquilino denominada App1. Tiene previsto registrar App1 con varios inquilinos de Microsoft Entra ID. Deberá identificar la relación entre los objetos de aplicación y las entidades de seguridad asociadas a App1. ¿Qué relación debería identificar?
    - **App1 tendrá un único objeto de aplicación y varias entidades de servicio**

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo configurar la autenticación de aplicaciones multiinquilino, que es un escenario común al implementar la autenticación. App1 tendrá un único objeto de aplicación y varias entidades de servicio. App1 no tendrá varios objetos de aplicación. varios objetos de aplicación y una sola entidad de servicio, o una sola entidad de servicio.


15. Tiene 10 aplicaciones que se ejecutan en Azure App Service Deberá asegurarse de que las aplicaciones tengan acceso a los elementos almacenados en Azure App Configuration mediante una configuración común. No se deben usar contraseñas ni claves. ¿Qué solución debe usar?
    - **Identidad administrada asignada por el usuario**

    Este elemento pone a prueba los conocimientos de los candidatos sobre las identidades administradas. Las identidades administradas asignadas por el usuario son una manera de reutilizar permisos entre aplicaciones. Las identidades administradas asignadas por el usuario asocian la identidad administrada a las nuevas aplicaciones, sin claves ni contraseñas. Las identidades administradas asignadas por el sistema usan una nueva identidad para cada aplicación, algo que no cumple con el requisito de configuración común. Una entidad de servicio tiene claves que deben rotarse. El desarrollador no ejecuta la aplicación, por lo que no se puede asumir la identidad del desarrollador.


16. Administra una aplicación web de Azure App Service denominada app1 y una instancia de Azure Key Vault denominada vault1. Debe asegurarse de que app1 puede autenticar y realizar operaciones con vault1 sin administrar la rotación de un secreto. El recurso necesario para implementar la solución debe eliminarse automáticamente cuando se elimina la aplicación. ¿Qué método de autenticación debería usar para app1?
    - **Identidad administrada asignada por el sistema**

    Este elemento pone a prueba los conocimientos de los candidatos sobre la implementación de Azure Key Vault, que forma parte de la implementación de soluciones de Secure Cloud. Se puede usar una identidad administrada asignada por el sistema para asegurarse de que app1 pueda autenticarse y realizar operaciones con vault1 sin administrar la rotación de secretos. Se puede usar una identidad administrada asignada por el usuario para asegurarse de que app1 pueda autenticarse y realizar operaciones con vault1, pero es necesario administrar la rotación de secretos. Una entidad de servicio y un secreto se pueden usar para autenticarse en el almacén de claves, pero es difícil rotar automáticamente el secreto que se usa para autenticarse en el almacén de claves. Se puede usar una entidad de servicio y un certificado asociado con el acceso al almacén de claves para la autenticación, pero requeriría administrar la rotación de un secreto.


17. Una empresa planea usar Azure App Configuration para las marcas de características en una aplicación.
La empresa tiene los siguientes requisitos de cifrado:
Claves administradas por el cliente
claves protegidas por módulos de seguridad de hardware (HSM)
Debe recomendar niveles de servicio.
¿Qué dos niveles debería recomendar? Cada respuesta correcta presenta parte de la solución.
    - **Nivel Estándar de Azure App Configuration**
    - **Nivel Premium de Azure Key Vault**

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de servicio para Azure App Configuration y Azure Key Vault.
    El nivel Estándar de App Configuration debe usarse para que las claves administradas por el cliente se usen en App Configuration. El nivel Premium de Key Vault es necesario para admitir claves protegidas con HSM. El nivel Gratis de App Configuration no permite el uso de claves administradas por el cliente. El nivel Estándar de Key Vault no admite claves protegidas con HSM.


18. Debe generar una nueva versión de una clave almacenada en Azure Key Vault.
¿Qué segmento de código debería usar?
    - **az keyvault key rotate --vault-name mykeyvault --name mykey**

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo establecer la rotación de claves mediante la CLI de Azure.
    La operación Rotate generará una nueva versión de la clave en función de la directiva de claves. La operación Rotation Policy actualiza la directiva de rotación de una clave del almacén de claves. La operación Purge Deleted Key es aplicable a almacenes o HSM habilitados para eliminación temporal. La operación Set Attributes cambia los atributos especificados de una clave almacenada.


19. Está desarrollando una solución que almacena secretos en una instancia de Azure Key Vault denominada myvault.
Necesita recuperar el valor de un secreto denominado mysecret que se almacena en myvault.
¿Qué comando de la CLI debería usar?
    - **az keyvault secret show --name mysecret --vault-name myvault**

    Este elemento pone a prueba los conocimientos de los candidatos sobre el desarrollo de código que use claves, secretos y certificados almacenados en Azure Key Vault. El comando de la CLI az keyvault ofrece varios comandos para trabajar con secretos. Los comandos más usados son set para almacenar un secreto y show para obtener el valor del secreto. Al usar estos comandos, debe especificarse un identificador que especifique la identificación de secreto completa (en el formato https://<keyvaultname>.vault.azure.net/secrets/<secret-name>/<secret-version>), o bien el secreto y el nombre del almacén.


20. Debe crear un contenedor en un grupo de contenedores y montar un recurso compartido de archivos de Azure como volumen.
¿Qué segmento de código debería usar?
    - **az container create -g MyResourceGroup --name myapp --image myimage:latest --command-line "cat /mnt/azfile/myfile" --azure-file-volume-share-name myshare --azure-file-volume-account-name mystorageaccount --azure-file-volume-account-key mystoragekey --azure-file-volume-mount-path /mnt/azfile**

    Este elemento pone a prueba los conocimientos de los candidatos sobre la ejecución de contenedores mediante Azure Container Instances.
    El segmento de código que incluye el parámetro –azure-file-volume-mount-path y el parámetro --azure-file-volume-share-name crea un contenedor en un grupo de contenedores y monta un recurso compartido de archivos de Azure como volumen.
    Los segmentos de código que incluyen el parámetro --secrets-mount-path no montarán un recurso compartido de archivos de Azure como volumen. El segmento de código que no incluye el parámetro --azure-file-volume-share-name no es válido.