# Desarrollo de soluciones para Microsoft Azure

1. Una empresa planea usar Azure Cache for Redis. La empresa planea usar módulos de Redis. Necesita recomendar un nivel de servicio de Azure Cache for Redis. ¿Qué nivel de servicio tiene que recomendar?
    - Enterprise

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de servicio de Azure Cache for Redis. Los módulos de Redis solo se admiten en el nivel de servicio Enterprise. Los niveles de servicio Básico, Estándar y Premium no admiten módulos de Redis.


1. Usted administra una instancia de Azure Cache for Redis. Necesita cargar datos a petición en la memoria caché desde una base de datos grande. ¿Qué patrón de arquitectura de aplicaciones debería usar?
    - Caché de datos

    Este elemento pone a prueba los conocimientos de los candidatos sobre el patrón de diseño de arquitectura de aplicaciones, que forma parte de la implementación del almacenamiento en caché para las soluciones. Las bases de datos suelen ser demasiado grandes para cargarse directamente en una memoria caché, por lo que es habitual usar el patrón de caché de datos. El almacén de sesiones se usa para almacenar información de sesión de usuarios en lugar de almacenar demasiados datos en una cookie que pueda afectar negativamente al rendimiento. Las transacciones distribuidas permiten que una serie de comandos se ejecuten en un almacén de datos de back-end como una sola operación. Mediante el uso de la caché de contenido, puede proporcionar acceso más rápido al contenido estático en comparación con los almacenes de datos de back-end. El almacén de sesiones, las transacciones distribuidas y la caché de contenido no se pueden usar para cargar datos a petición.


1. Usted administra Azure Cache for Redis mediante clases en el espacio de nombres .NET StackExchange.Redis. Debe recuperar una referencia de una base de datos de Redis mediante el método GetDatabase. ¿Qué debería que hacer en primer lugar?
    - Crear un objeto ConnectionMultiplexer

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo interactuar mediante programación con Azure Cache for Redis, que es una parte integral de la implementación de patrones de caché de aplicaciones seguros y optimizados, incluyendo el ajuste de tamaño de datos, las conexiones, el cifrado y la expiración. La creación de un objeto ConnectionMultiplexer es el primer paso necesario para recuperar una referencia a una base de datos de Redis mediante el método GetDatabase. Se requiere crear un objeto CdnManagementClient cuando se use el almacenamiento en caché de Azure Content Delivery Network, no Azure Cache for Redis. Llamar a un método StringSet permitirá administrar el contenido de una base de datos de Redis, lo que se producirá una vez que el objeto ConnectionMultiplexer y la base de datos se hayan creado. Llamar a un método StringGet permitirá recuperar el contenido de una base de datos de Redis, lo que se producirá una vez que el objeto ConnectionMultiplexer y la base de datos se hayan creado.


1. Tiene previsto usar Azure Cache for Redis como capa de almacenamiento en caché para varias aplicaciones. Tiene los siguientes requisitos: Evitar la pérdida de datos si los nodos están inactivos. Minimizar los costes de almacenamiento. Optimizar el rendimiento. ¿Qué solución debe usar?
    - Persistencia de la base de datos de Redis (RDB) con la característica de eliminación temporal deshabilitada en la cuenta de almacenamiento asociada

    Este elemento pone a prueba los conocimientos de los candidatos sobre la persistencia de datos en Azure Cache for Redis. La persistencia de RDB guarda copias de seguridad en función del intervalo de copia de seguridad configurado con un efecto mínimo en el rendimiento. Deshabilitar la característica de eliminación temporal en una cuenta de almacenamiento implica que Azure Cache for Redis no puede minimizar los costes de almacenamiento mediante la eliminación de los datos de copia de seguridad antiguos. Habilitar la característica de eliminación temporal en una cuenta de almacenamiento implica que Azure Cache for Redis no puede minimizar los costes de almacenamiento mediante la eliminación de los datos de copia de seguridad antiguos. La persistencia de AOF guarda cada escritura en un registro, lo que tiene un efecto significativo en el rendimiento. Deshabilitar y habilitar la característica de eliminación temporal en una cuenta de almacenamiento implica que Azure Cache for Redis no puede minimizar los costes de almacenamiento mediante la eliminación de los datos de copia de seguridad antiguos.


1. Tiene la siguiente clase GameStat:
    ```java
    public class GameStat
    {
        public string Id { get; set; }
        public string Sport { get; set; }
        public DateTimeOffset DatePlayed { get; set; }
        public string Game { get; set; }
        public IReadOnlyList<string> Teams { get; set; }
        public IReadOnlyList<(string team, int score)> Results { get; set; }

        public GameStat(string sport, DateTimeOffset datePlayed, string game, string[] teams, IEnumerable<(string team, int score)> results)
        {
            Id = Guid.NewGuid().ToString();
            Sport = sport;
            DatePlayed = datePlayed;
            Game = game;
            Teams = teams.ToList();
            Results = results.ToList();
        }

        public override string ToString()
        {
            return $"{Sport} {Game} played on {DatePlayed.Date.ToShortDateString()} - " +
                $"{String.Join(',', Teams)}\r\n\t" + 
                $"{String.Join('\t', Results.Select(r => $"{r.team } - {r.score}\r\n"))}";
        }
    }
    ```
    Debe almacenar una instancia de la clase GameStat en Azure Cache for Redis. ¿Qué dos segmentos de código debería usar? Cada respuesta correcta presenta una solución completa.

    - 
    ```java
    var stat = new GameStat("Soccer", new DateTime(2019, 7, 16), "Local Game", new[] { "Team 1", "Team 2" }, new[] { ("Team 1", 2), ("Team 2", 1) }); string serializedValue = System.Text.Json.JsonSerializer.Serialize (stat); bool added = db.StringSet("event:1950-world-cup", serializedValue);
    ```

    - 
    ```java
    var stat = new GameStat("Soccer", new DateTime(2019, 7, 16), "Local Game", new[] { "Team 1", "Team 2" }, new[] { ("Team 1", 2), ("Team 2", 1) }); bool added = db.StringSet("event:1950-world-cup", stat.ToString());
    ```

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo implementar el almacenamiento en caché. Los segmentos de código que incluyen la operación StringSet serializarán y almacenarán correctamente el contenido de la clase GameStat en Azure Cache for Redis. Los segmentos de código que incluyen la operación StringGet no lo harán.


1. Tiene una aplicación web de Azure que ocasionalmente experimenta tiempos de respuesta elevados. Debe recibir una notificación cuando el tiempo de respuesta supere un umbral determinado. ¿Qué tiene que hacer?
    - Implemente alertas y pruebas web de Application Insights

    Application Insights permite crear pruebas web que simulan interacciones de usuario con la aplicación y, a continuación, configuran alertas basadas en los resultados de estas pruebas. Las alertas de Resource Health de Azure Monitor se usan para la supervisión de la infraestructura, no para el rendimiento de las aplicaciones. Azure Service Health proporciona información sobre los problemas del servicio de Azure y el mantenimiento planeado, no sobre el rendimiento de las aplicaciones. Azure Advisor proporciona recomendaciones de procedimientos recomendados, no alertas de rendimiento de aplicaciones.


1. El equipo está desarrollando una nueva característica para una aplicación existente basada en Azure que depende en gran medida en el procesamiento de datos en tiempo real. La característica implica la integración de varios servicios de Azure y API de terceros. Debe crear una estrategia para asegurarse de que la integración de estos servicios no presenta ningún problema de rendimiento ni errores. Debe diseñar la solución de supervisión para detectar y solucionar posibles problemas. ¿Qué tiene que hacer?
    - Use Live Metrics en Application Insights para observar la actividad de la aplicación implementada en tiempo real

    La opción D es correcta porque Live Metrics proporciona observación en tiempo real de la actividad de la aplicación, lo que permite la detección inmediata y la respuesta a los problemas de rendimiento. La opción C es incorrecta, ya que es posible que las comprobaciones nocturnas no sean suficientes para las necesidades de procesamiento de datos en tiempo real. La opción A es incorrecta porque una sola prueba de disponibilidad no proporciona una supervisión completa de todos los servicios integrados. La opción B es incorrecta, ya que la revisión manual de los registros no es eficaz para la supervisión en tiempo real y puede retrasar la respuesta a los problemas.


1. Un equipo de desarrollo usa Application Insights para supervisar su aplicación web implementada en Azure. Han observado discrepancias en las métricas notificadas debido a un gran volumen de telemetría. Debe asegurarse de que las métricas notificadas reflejen con precisión el rendimiento de la aplicación sin verse afectados por el muestreo de telemetría. ¿Qué debería implementar para conseguir este objetivo?
    - Configure Application Insights para usar métricas estándar agregadas previamente para paneles y alertas en tiempo real

    Las métricas estándar agregadas previamente no se ven afectadas por el muestreo de telemetría y proporcionan datos precisos en tiempo real, lo que hace que sean adecuados para paneles y alertas. Aumentar la frecuencia de muestreo o deshabilitar el muestreo por completo aumentaría los costos y es posible que aún no proporcione métricas precisas debido al volumen de datos. La creación de una consulta de Kusto personalizada requeriría un esfuerzo manual y no soluciona el problema del muestreo que afecta a las métricas.


1. Tiene previsto usar Microsoft Graph para recuperar una lista de usuarios en un inquilino de Microsoft Entra ID. Es necesario optimizar los resultados de la consulta. ¿Qué dos opciones de consulta debería usar? Cada respuesta correcta presenta parte de la solución.
    - $filter
    - $select

    Este elemento pone a prueba los conocimientos de los candidatos sobre las opciones de consulta de Microsoft Graph La opción de consulta $filter debe usarse para limitar los resultados devueltos. La opción de consulta $select limita los atributos proyectados desde el conjunto de resultados, lo que hace que la consulta sea más eficaz. La opción de consulta $count está pensada para recuperar el recuento total de recursos coincidentes. La opción de consulta $expand se usa para recuperar recursos relacionados.


1. Tiene una cuenta de Azure Storage. Es necesario proporcionar a los usuarios externos la capacidad de crear y actualizar blobs. ¿Qué valor de enumeración de BlobSasPermissions debería usar?
    - Escribir

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo crear e implementar blobs. El permiso de escritura permitirá a los usuarios crear y actualizar blobs. El permiso Agregar solo es aplicable a blobs anexos. El permiso Crear solo permite a los usuarios crear blobs. No permite a los usuarios actualizar blobs. El permiso de lectura no permite a los usuarios crear y actualizar blobs.


1. Administra una aplicación web de Azure App Service denominada app1. App1 se registra como una aplicación multiinquilino en un inquilino de Microsoft Entra ID denominado tenant1. Debe conceder a app1 el permiso para acceder a Microsoft Graph API en tenant1.¿Qué entidad de servicio debería usar?
    - application

    Este elemento pone a prueba los conocimientos de los candidatos sobre el acceso a los datos de usuario desde Microsoft Graph, que forma parte de la implementación de la autenticación y autorización del usuario. Una aplicación de Microsoft Entra ID se define por su único objeto de aplicación, que reside en el inquilino de Microsoft Entra ID donde se registró la aplicación, (conocido como inquilino "principal" de la aplicación). La entidad de servicio de la aplicación se usa para configurar el permiso de app1 en tenant1 para acceder a Microsoft Graph API. La entidad de servicio heredada es una aplicación heredada (la que se ha creado antes de que se introdujeran o crearan registros de aplicaciones mediante experiencias heredadas). Las identidades administradas eliminan la necesidad de administrar las credenciales en el código. Solo hay una identidad administrada asignada por cada recurso y está asociada al ciclo de vida del recurso. Las identidades administradas para los recursos de Azure eliminan la necesidad de administrar las credenciales en el código. Una identidad administrada asignada por el usuario se puede crear y asignar a una o varias instancias de un servicio de Azure. La identidad administrada asignada por el usuario y la identidad administrada asignada por el sistema heredadas no se pueden usar para asignar permisos para app1 en tenant1 para acceder a Microsoft Graph API.


1. Desarrolla una aplicación. Un proveedor tendrá acceso a la aplicación. El proveedor requiere una firma de acceso compartido (SAS) para acceder a los servicios de Azure en su suscripción de la empresa. Debe proteger la SAS. ¿Qué tres acciones debe realizar? Cada respuesta correcta presenta una solución completa.
    - Use siempre HTTPS
    - Use registros de Azure Monitor y Azure Storage para supervisar la aplicación
    - Defina una directiva de acceso almacenada para una SAS de servicio

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo implementar firmas de acceso compartido (SAS). La recomendación de usar siempre HTTPS es válida y debería seguirse. Azure Monitor y el registro de Storage Analytics deberían usarse para observar cualquier pico en estos tipos de errores de autorización. Las directivas de acceso almacenadas le ofrecerán la posibilidad de revocar permisos para una SAS de servicio sin tener que volver a generar las claves de la cuenta de almacenamiento. Un procedimiento recomendado de seguridad es proporcionar al usuario los privilegios mínimos necesarios. Es mejor usar tiempos de expiración de corto plazo en servicios de SAS ad hoc o cuentas de SAS para que, incluso aunque una SAS estuviera en peligro, solo sería válida durante un tiempo breve.


1. Administra una aplicación registrada de Microsoft Entra ID denominada app1. App1 llama a una API web, que luego llamará a Microsoft Graph. Debe asegurarse de que la identidad del usuario que inició sesión se delegue a través de la cadena de solicitudes. ¿Qué flujo de autenticación debería usar?
    - On-Behalf-Of

    Este elemento pone a prueba los conocimientos de los candidatos sobre el acceso a los datos de usuario desde Microsoft Graph, que forma parte de la implementación de la autenticación y autorización del usuario. Flujo OAuth 2.0 On-Behalf-Of (OBO) se usa cuando una aplicación invoca un servicio o API web, que, a su vez, debe llamar a otro servicio o API web. La idea es propagar la identidad del usuario delegado y los permisos a través de la cadena de solicitudes. La concesión de un código de autorización de OAuth 2.0 se puede usar en aplicaciones que se instalan en un dispositivo para obtener acceso a recursos protegidos, como las API web. El flujo de concesión de credenciales de cliente de OAuth 2.0 permite que un servicio web (cliente confidencial) use sus propias credenciales para autenticarse al llamar a otro servicio web, en lugar de suplantar a un usuario. Implícito es un flujo basado en redirección. El cliente debe ser capaz de interactuar con el agente de usuario del propietario del recurso (normalmente un explorador web). El código de autorización, On-Behalf-Of e Implícito no se pueden usar para delegar el permiso y la identidad del usuario.


1. Desarrolla una aplicación web multiinquilino denominada App1. Tiene previsto registrar App1 con varios inquilinos de Microsoft Entra ID. Deberá identificar la relación entre los objetos de aplicación y las entidades de seguridad asociadas a App1. ¿Qué relación debería identificar?
    - App1 tendrá un único objeto de aplicación y varias entidades de servicio

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo configurar la autenticación de aplicaciones multiinquilino, que es un escenario común al implementar la autenticación. App1 tendrá un único objeto de aplicación y varias entidades de servicio. App1 no tendrá varios objetos de aplicación. varios objetos de aplicación y una sola entidad de servicio, o una sola entidad de servicio.


1. Tiene 10 aplicaciones que se ejecutan en Azure App Service Deberá asegurarse de que las aplicaciones tengan acceso a los elementos almacenados en Azure App Configuration mediante una configuración común. No se deben usar contraseñas ni claves. ¿Qué solución debe usar?
    - Identidad administrada asignada por el usuario

    Este elemento pone a prueba los conocimientos de los candidatos sobre las identidades administradas. Las identidades administradas asignadas por el usuario son una manera de reutilizar permisos entre aplicaciones. Las identidades administradas asignadas por el usuario asocian la identidad administrada a las nuevas aplicaciones, sin claves ni contraseñas. Las identidades administradas asignadas por el sistema usan una nueva identidad para cada aplicación, algo que no cumple con el requisito de configuración común. Una entidad de servicio tiene claves que deben rotarse. El desarrollador no ejecuta la aplicación, por lo que no se puede asumir la identidad del desarrollador.


1. Administra una aplicación web de Azure App Service denominada app1 y una instancia de Azure Key Vault denominada vault1. Debe asegurarse de que app1 puede autenticar y realizar operaciones con vault1 sin administrar la rotación de un secreto. El recurso necesario para implementar la solución debe eliminarse automáticamente cuando se elimina la aplicación. ¿Qué método de autenticación debería usar para app1?
    - Identidad administrada asignada por el sistema

    Este elemento pone a prueba los conocimientos de los candidatos sobre la implementación de Azure Key Vault, que forma parte de la implementación de soluciones de Secure Cloud. Se puede usar una identidad administrada asignada por el sistema para asegurarse de que app1 pueda autenticarse y realizar operaciones con vault1 sin administrar la rotación de secretos. Se puede usar una identidad administrada asignada por el usuario para asegurarse de que app1 pueda autenticarse y realizar operaciones con vault1, pero es necesario administrar la rotación de secretos. Una entidad de servicio y un secreto se pueden usar para autenticarse en el almacén de claves, pero es difícil rotar automáticamente el secreto que se usa para autenticarse en el almacén de claves. Se puede usar una entidad de servicio y un certificado asociado con el acceso al almacén de claves para la autenticación, pero requeriría administrar la rotación de un secreto.


1. Una empresa planea usar Azure App Configuration para las marcas de características en una aplicación.
La empresa tiene los siguientes requisitos de cifrado:
Claves administradas por el cliente
claves protegidas por módulos de seguridad de hardware (HSM)
Debe recomendar niveles de servicio.
¿Qué dos niveles debería recomendar? Cada respuesta correcta presenta parte de la solución.
    - Nivel Estándar de Azure App Configuration
    - Nivel Premium de Azure Key Vault

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de servicio para Azure App Configuration y Azure Key Vault.
    El nivel Estándar de App Configuration debe usarse para que las claves administradas por el cliente se usen en App Configuration. El nivel Premium de Key Vault es necesario para admitir claves protegidas con HSM. El nivel Gratis de App Configuration no permite el uso de claves administradas por el cliente. El nivel Estándar de Key Vault no admite claves protegidas con HSM.


1. Debe generar una nueva versión de una clave almacenada en Azure Key Vault.
¿Qué segmento de código debería usar?
    - az keyvault key rotate --vault-name mykeyvault --name mykey

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo establecer la rotación de claves mediante la CLI de Azure.
    La operación Rotate generará una nueva versión de la clave en función de la directiva de claves. La operación Rotation Policy actualiza la directiva de rotación de una clave del almacén de claves. La operación Purge Deleted Key es aplicable a almacenes o HSM habilitados para eliminación temporal. La operación Set Attributes cambia los atributos especificados de una clave almacenada.


1. Está desarrollando una solución que almacena secretos en una instancia de Azure Key Vault denominada myvault.
Necesita recuperar el valor de un secreto denominado mysecret que se almacena en myvault.
¿Qué comando de la CLI debería usar?
    - az keyvault secret show --name mysecret --vault-name myvault

    Este elemento pone a prueba los conocimientos de los candidatos sobre el desarrollo de código que use claves, secretos y certificados almacenados en Azure Key Vault. El comando de la CLI az keyvault ofrece varios comandos para trabajar con secretos. Los comandos más usados son set para almacenar un secreto y show para obtener el valor del secreto. Al usar estos comandos, debe especificarse un identificador que especifique la identificación de secreto completa (en el formato https://<keyvaultname>.vault.azure.net/secrets/<secret-name>/<secret-version>), o bien el secreto y el nombre del almacén.


1. Debe crear un contenedor en un grupo de contenedores y montar un recurso compartido de archivos de Azure como volumen.
¿Qué segmento de código debería usar?
    - az container create -g MyResourceGroup --name myapp --image myimage:latest --command-line "cat /mnt/azfile/myfile" --azure-file-volume-share-name myshare --azure-file-volume-account-name mystorageaccount --azure-file-volume-account-key mystoragekey --azure-file-volume-mount-path /mnt/azfile

    Este elemento pone a prueba los conocimientos de los candidatos sobre la ejecución de contenedores mediante Azure Container Instances.
    El segmento de código que incluye el parámetro –azure-file-volume-mount-path y el parámetro --azure-file-volume-share-name crea un contenedor en un grupo de contenedores y monta un recurso compartido de archivos de Azure como volumen.
    Los segmentos de código que incluyen el parámetro --secrets-mount-path no montarán un recurso compartido de archivos de Azure como volumen. El segmento de código que no incluye el parámetro --azure-file-volume-share-name no es válido.


1. Debe eliminar una imagen con la etiqueta dev/nginx:latest de un registro de contenedor de Azure denominado devregistry.
¿Qué segmento de código debería usar?
    - az acr repository delete --name devregistry --image dev/nginx:latest

    Este elemento pone a prueba los conocimientos de los candidatos sobre la publicación o eliminación de imágenes en Azure Container Registry.
    El segmento de código az acr repository delete --name devregistry --image dev/nginx:latest eliminará la imagen de un registro de contenedor. Los segmentos de código que incluyan el parámetro sufijo se deben usar si se accede al registro desde otra suscripción o se tiene permiso para acceder a imágenes, pero no para administrar el recurso del registro. Los segmentos de código que incluyen los parámetros manifest eliminan el manifiesto del artefacto, no la imagen.


1. Desarrolla una aplicación web hospedada en la característica Web Apps de Microsoft Azure App Service.
Es necesario habilitar y configurar la caché local del servicio web de Azure con 1,5 GB.
¿Qué dos segmentos de código debería usar? Cada respuesta correcta presenta parte de la solución.
    - “WEBSITE_LOCAL_CACHE_OPTION”: “Always”
    - “WEBSITE_LOCAL_CACHE_SIZEINMB”: “1500”
    
    Este elemento pone a prueba los conocimientos de los candidatos sobre la configuración de las opciones de la característica Web Apps de Azure App Service.
    Con WEBSITE_LOCAL_CACHE_OPTION = Always, se habilitará la caché local. WEBSITE_LOCAL_CACHE_SIZEINMB configurará correctamente la caché local con un tamaño de 1,5 GB. WEBSITE_LOCAL_CACHE_OPTION = Enable no es un valor válido. 1.5 no configurará 1,5 GB para la caché local.


1. Tiene previsto desarrollar una aplicación web de Azure App Service denominada app1 mediante un contenedor personalizado de Windows.
Debe cargar un certificado TLS/SSL en el código de la aplicación.
¿Qué configuración de la aplicación debería configurar? 
    - WEBSITE_LOAD_CERTIFICATES

    Este elemento pone a prueba los conocimientos de los candidatos sobre la configuración de la aplicación, lo que forma parte de la creación de Azure App Service Web Apps.
    La configuración de la aplicación WEBSITE_LOAD_CERTIFICATES hace que los certificados especificados sean accesibles para contenedores personalizados de Windows o Linux como archivos. La configuración de la aplicación WEBSITE_ROOT_CERTS_PATH es de solo lectura y no permite que los valores de huella digital separados por comas sean mencionados a los certificados y, a continuación, se carguen en el código. La configuración de la aplicación WEBSITE_AUTH_TOKEN_CONTAINER_SASURL se usa para indicar al módulo de autenticación que almacene y cargue todos los tokens cifrados en el contenedor de almacenamiento de blobs especificado. Esta configuración se usa para Azure Storage y no se puede usar para cargar certificados dentro de un contenedor personalizado de Windows.


1. Administra las ranuras de implementación de ensayo y producción de una aplicación web de Azure App Service denominada app1.
Necesita asegurarse de que no se intercambie una cadena de conexión cuando se realice el intercambio.
¿Qué configuración debe usar?
    - Configuración de ranura de implementación

    Este elemento pone a prueba los conocimientos de los candidatos sobre la implementación de código en Azure App Service, que forma parte de la creación de Azure App Service Web Apps.
    Marcar una configuración como una configuración de ranura de implementación la mantendrá pegada a esa ranura de implementación. Por ejemplo, una configuración de aplicación marcada como una configuración de ranura de implementación en app1 siempre se mantendrá con app1 y nunca se moverá a app1/staging durante un intercambio. La configuración del Centro de implementación se usa para configurar la implementación continua y la implementación manual. La identidad administrada proporciona una identidad que usan las aplicaciones al conectarse a los recursos que admiten la autenticación de Microsoft Entra ID. El escalado vertical garantizará que la aplicación web tenga derecho a obtener CPU, memoria, espacio en disco y características adicionales, como máquinas virtuales dedicadas, dominios personalizados y certificados, ranuras de ensayo y escalado automático. No se puede usar el centro de implementación, la identidad administrada y el escalado vertical para asegurarse de que no se intercambie una cadena de conexión cuando se realice el intercambio.


1. Una empresa planea implementar una solución de Microsoft Defender for Cloud.
La empresa tiene los siguientes requisitos:
Notifica cuándo no se eliminan los dominios DNS cuando se elimina una nueva aplicación de Azure Functions.
Usar alertas nativas.
Minimización de costes.
Debe seleccionar un plan de hospedaje.
¿Qué plan de hospedaje debería usar?
    - Basic

    Este elemento pone a prueba los conocimientos de los candidatos sobre la protección de Azure Functions.
    El plan Básico admite dominios personalizados y Microsoft Defender for Cloud, lo que podría alertar automáticamente sobre dominios DNS pendientes. El plan Consumo es incorrecto porque no es compatible con Microsoft Defender for Cloud. Esto podría alertar automáticamente sobre dominios DNS pendientes. El plan Premium admite dominios personalizados y Microsoft Defender for Cloud, lo que podría alertar automáticamente sobre dominios DNS pendientes. Sin embargo, esta no es la opción con el coste más bajo. El plan Gratis no admite dominios personalizados, aunque admite Microsoft Defender for Cloud, lo que podría alertar automáticamente sobre dominios DNS pendientes.


1. Usted crea una rutina por lotes mediante un desencadenador de temporizador en Azure Functions.
Debe configurar la rutina por lotes para que se ejecute cada 15 minutos, de lunes a viernes.
¿Qué segmento de código debería usar?

    - 
    ```java
    [Function(nameof(TimerTriggerCSharp))] [FixedDelayRetry(5, "00:00:10")] public static void Run([TimerTrigger("0 */15 * * * 1-5")] TimerInfo myTimer, FunctionContext context) { var log = context.GetLogger(nameof(TimerFunction)); if (myTimer.IsPastDue) { log.LogInformation("Timer is running late!"); } log.LogInformation($"C# Timer trigger function executed at: {DateTime.Now}"); }
    ```

    Este elemento pone a prueba los conocimientos de los candidatos sobre trabajar con desencadenadores de temporizador en Azure Functions.
    El segmento de código que incluye Run([TimerTrigger("0 */15 * * * * 1-5") ejecuta la función cada 15 minutos de lunes a viernes. Al segmento de código que incluye Run([TimerTrigger("*/15 * * * 0-4") le falta la segunda parte y no usa el intervalo adecuado en los días de la semana. El segmento de código que incluye Run([TimerTrigger("0 15 * * * ") se ejecuta solo una vez a las 15:00 (3 p.m.). Al segmento de código que incluye Run([TimerTrigger("* 15 * * 1-5") le falta el atributo seconds y la parte del paso ('/') en los minutos.


1. Está desarrollando una aplicación de .NET que incluye varias imágenes de contenedor. La aplicación se implementará en Azure Container Instances (ACI).
Es necesario asegurarse de que un recurso compartido de archivos de Azure se pueda asignar a cada contenedor de la aplicación.
¿Qué configuración debe usar?
    - grupo de contenedores

    Este elemento pone a prueba los conocimientos de los candidatos de la ejecución de contenedores mediante Azure Container Instances (ACI). El recurso de nivel superior de ACI es el grupo de contenedores. Un grupo de contenedores es una colección de contenedores que se programan en la misma máquina host. Puede especificar volúmenes externos para montar dentro de un grupo de contenedores. Puede asignar los volúmenes en rutas de acceso específicas dentro de los contenedores individuales en un grupo. Un pod es un grupo de uno o varios contenedores con recursos de red y almacenamiento compartidos, además de especificaciones para ejecutar los contenedores. Los pods se pueden usar en Azure Kubernetes Service, pero no en ACI. Los contenedores confidenciales de ACI se usan para garantizar la confidencialidad basada en hardware. ACI permite la implementación de instancias de contenedor en una red virtual de Azure. No se puede usar una implementación de red virtual para asignar un recurso compartido de archivos de Azure a cada contenedor en un escenario de varios contenedores.


1. Un grupo de contenedores en Azure Container Instances tiene varios contenedores.
Los contenedores deberán reiniciarse cuando el proceso ejecutado en el grupo de contenedores finalice por un error.
Debe definir la directiva de reinicio para el grupo de contenedores.
¿Qué comando de la CLI de Azure debe ejecutar?
    - az container create \ --resource-group myResourceGroup \ --name mycontainer \ --image mycontainerimage \ --restart-policy OnFailure

    Este elemento pone a prueba los conocimientos de los candidatos de la ejecución de contenedores mediante Azure Container Instances (ACI). Las directivas de reinicio configurables se pueden especificar para un grupo de contenedores en ACI. Una directiva de reinicio configurable permite especificar que los contenedores se detengan cuando se hayan completado sus procesos. Al crear un grupo de contenedores en ACI, es posible especificar una de las tres opciones de configuración de directiva de reinicio: Siempre, Nunca y OnFailure.
    Si la directiva de reinicio se menciona como OnFailure, los contenedores del grupo de contenedores solo se reiniciarán cuando se produzca un error en el proceso ejecutado en el contenedor (cuando finalice con un código de salida distinto de cero). Si la directiva de reinicio se menciona como Siempre, los contenedores del grupo de contenedores siempre se reiniciarán independientemente del éxito o error de ejecución del proceso en un contenedor. Si la directiva de reinicio se menciona como Nunca, los contenedores del grupo de contenedores solo se ejecutarán como máximo una vez.
    El comando az container restart se usa para reiniciar todos los contenedores de un grupo de contenedores, no para definir una directiva de reinicio para un grupo de contenedores.


1. Está desarrollando una aplicación de tareas en segundo plano de contenedor nativa en la nube.
Debe elegir la opción de implementación de contenedor adecuada en función de los siguientes requisitos:
Minimización del costo
Compatibilidad con la detección de servicios y la división de tráfico
Habilitación de la arquitectura de aplicaciones controladas por eventos
No requiere acceso a la API nativa de Kubernetes
¿Qué debe usar?
    - Azure Container Apps

    Este elemento pone a prueba los conocimientos de los candidatos para crear soluciones mediante Azure Container Apps. Azure Container Apps permite crear microservicios sin servidor basados en contenedores. Está optimizado para ejecutar contenedores de uso general y proporciona muchos conceptos específicos de la aplicación sobre los contenedores. Azure Spring Apps es un servicio totalmente administrado destinado a desarrolladores de Spring. Proporciona administración del ciclo de vida para ejecutar Spring Boot, Spring Cloud o cualquier otra aplicación de Spring en Azure. Azure Container Instances no admite el escalado, el equilibrio de carga, las revisiones, la escala o los entornos, además de no cumplir con los requisitos mencionados. Azure Functions es una solución de funciones como servicio (FaaS) sin servidor. Se puede usar para la ejecución de aplicaciones controladas por eventos mediante el modelo de programación de funciones. Sin embargo, no se puede usar para implementar una imagen de contenedor.


1. Está desarrollando una aplicación web Linux en Azure App Service.
Debe implementar la aplicación web en el entorno de producción en función de los siguientes requisitos:
Los cambios de la aplicación deben validarse en un entorno idéntico al entorno de producción antes de mover la aplicación al entorno de producción.
El tiempo de inactividad deberá eliminarse cuando la aplicación se implemente en el entorno de producción.
¿Qué debe usar?
    - Ranuras de implementación

    Este elemento pone a prueba los conocimientos de los candidatos sobre cuándo usar ranuras de implementación. Las ranuras de implementación son aplicaciones en directo con nombres de host únicos, lo que permite intercambiar la configuración y el contenido entre ellas. El escalado automático es una característica que permite agregar más capacidad a un entorno de hospedaje de aplicaciones de Azure Functions. Esta capacidad se puede agregar a un entorno de hospedaje individual (por ejemplo, escalar verticalmente, o bien agregar memoria o CPU) o añadiendo más hosts (escalado horizontal). El escalado se puede desencadenar en función de una programación o al infringir los umbrales definidos para determinadas métricas. Las conexiones híbridas están disponibles para consumir aplicaciones locales sin necesidad de exponerlas a Internet. La clonación de aplicaciones es un proceso para obtener una aplicación existente y copiarla en otro destino, que podría ser una aplicación nueva o una ranura de implementación, por ejemplo. Sin embargo, no es compatible con aplicaciones Linux.


1. Administra una base de datos de Azure Cosmos DB denominada database1.
Es necesario leer elementos de la base de datos sin ninguna garantía de ordenación y garantizar la máxima disponibilidad.
¿Qué nivel de coherencia debería usar?
    - Posible

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de coherencia en Azure Cosmos DB, que forma parte del desarrollo de soluciones que usan el almacenamiento de Azure Cosmos DB.
    La coherencia final tiene la coherencia más flexible y confirma cualquier operación de escritura en la principal inmediatamente. Esto proporcionará la disponibilidad más alta y la coherencia más baja. La coherencia fuerte ofrece una garantía de linearización. La linearización hace referencia a la capacidad de servir solicitudes simultáneamente. Se garantiza que los usuarios siempre leerán la escritura confirmada más reciente. Una coherencia fuerte sufrirá de disponibilidad reducida. La coherencia de obsolescencia limitada no proporcionará la máxima disponibilidad. Cuando un cliente realiza operaciones de lectura dentro de una región que acepta escrituras, las garantías proporcionadas por la coherencia de obsolescencia limitada y la coherencia fuerte serán idénticas. La coherencia de la sesión garantizará que en una sesión de usuario todas las operaciones de lectura y escritura sean coherentes. Dado que la aplicación no requiere garantía de coherencia, este nivel de coherencia no es adecuado.


1. Administra un contenedor de Azure Cosmos DB denominado container1.
Debe usar el método ReadItemAsync para leer un elemento del servicio Azure Cosmos.
¿Qué dos parámetros deberá proporcionar? Cada respuesta correcta presenta parte de la solución.
    - partitionKey
    - id

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo establecer la clave de partición, lo que forma parte del desarrollo de soluciones de Azure Cosmos DB.
    El método ReadItemAsync de la clase de contenedor del SDK de .NET para Azure Cosmos DB tiene dos parámetros obligatorios: partitionKey e itemId. El parámetro consistencyLevel forma parte del parámetro requestOptions opcional del ReadItemAsync.
    Los parámetros eTag y sessionToken forman parte del parámetro requestOptions opcional del método ReadItemAsync.


1. Tiene una aplicación que escribe datos en Azure Cosmos DB.
La aplicación debe ofrecer lecturas monotónicas, sin ninguna garantía de que el valor leído sea el último valor escrito.
Es necesario configurar el nivel de coherencia.
¿Qué nivel de coherencia debería usar?
    - session

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de coherencia de Azure Cosmos DB.
    La coherencia de la sesión ofrece todas las garantías enumeradas. Proporciona latencias de escritura, disponibilidad y rendimiento de lectura comparables a los de la coherencia posible. También proporciona garantías de coherencia que satisfacen las necesidades de las aplicaciones escritas para funcionar en el contexto de usuarios. La coherencia fuerte tiene lecturas garantizadas para devolver la versión confirmada más reciente de un elemento. Un cliente nunca ve una escritura no confirmada ni parcial. Se garantiza que los usuarios leerán la escritura confirmada más reciente. Tiene la latencia de escritura más alta y el rendimiento de lectura más bajo de todos los niveles de coherencia. En la obsolescencia limitada se garantiza que las lecturas respetan la garantía de prefijo coherente. Se debe usar cuando se necesiten latencias de escritura bajas, pero se requiere una garantía total de orden global. En la coherencia final, no hay ninguna garantía de ordenación para las lecturas. En ausencia de escrituras adicionales, las réplicas terminarán por converger. Es la forma más débil de coherencia, ya que un cliente podría leer valores que sean más antiguos que los que había leído antes. La coherencia final es adecuada cuando la aplicación no requiere ninguna garantía de ordenación.


1. Tiene blobs en Azure Blob Storage. Los blobs almacenan imágenes.
Es necesario registrar la información sobre la ubicación y las condiciones meteorológicas desde el momento en que se tomaron las imágenes. Asegúrese de poder usar hasta 2000 caracteres al grabar la información.
¿Qué tiene que hacer?
    - Use encabezados de metadatos definidos con una solicitud PUT

    Este elemento pone a prueba los conocimientos de los candidatos sobre la estructuración de datos para Blob Storage.
    Los metadatos son la manera adecuada de definir este tipo de datos, lo que permite realizar modificaciones independientes y admitir hasta 8 KB de tamaño total. El verbo HTTP para definir metadatos es PUT y este es el formato correcto para definir valores de metadatos. El tamaño máximo de un nombre de blob es de 1024 caracteres. Además, esto no es un enfoque óptimo porque los metadatos se pueden obtener y establecer de forma independiente, manteniendo el mismo nombre de archivo. Los metadatos son la manera adecuada de definir este tipo de datos, lo que permite realizar modificaciones independientes y admitir hasta 8 KB de tamaño total. Pero el verbo HTTP para definir metadatos es PUT, no POST. La combinación de ubicaciones y tipos meteorológicos puede ser potencialmente ilimitada, y los nombres de contenedor están limitados a 63 caracteres.


1. Debe descargar el contenido del blob en una matriz de bytes mediante una operación que se recupera automáticamente frente a errores transitorios.
¿Qué instrucción de código debería usar?

    - 
    ```java
    byte[] data; BlobClientOptions options = new BlobClientOptions(); options.Retry.MaxRetries = 10; options.Retry.Delay = TimeSpan.FromSeconds(20); BlobClient client = new BlobClient(new Uri("https://mystorageaccount.blob.core.windows.net/containers/blob.txt"), options); Response response = client.DownloadContent(); data = response.Value.Content.ToArray();
    ```

    Este elemento prueba los conocimientos de los candidatos sobre la implementación de directivas de almacenamiento.
    El segmento de código que incluye options.Retry.MaxRetries = 10; y options.Retry.Delay = TimeSpan.FromSeconds(20); define la estrategia de reintentos y descarga el contenido en los datos de la variable. Los segmentos de código que no incluyen estos parámetros no definen la estrategia de reintento.


1. Una empresa usa Azure Container Instances para una aplicación.
Necesita asegurarse de que los contenedores se reinicien cuando el proceso finalice con un código de salida distinto de cero.
¿Qué debería hacer?
    - Define una directiva de reinicio de contenedor de `Siempre`.

    Este elemento pone a prueba los conocimientos de los candidatos sobre las directivas de reinicio en Azure Container Instances.
    Los contenedores del grupo de contenedores siempre se reinician con una directiva Always en vigor, independientemente de su código de salida. La ejecución de contenedores mediante una identidad administrada simplificaría el acceso a los recursos externos de Azure, pero hacerlo no tendrá ningún efecto cuando se reinicie un contenedor. Cuando se produzca un error en los procesos del contenedor (finalizando con un código de salida distinto de cero), no se reiniciarán y solo se ejecutarán una vez como máximo. Los contenedores de inicialización están diseñados para realizar la lógica de inicialización para los contenedores de aplicaciones, ejecutándose hasta completarse antes de que se inicien los contenedores de aplicaciones.


1. Administra una aplicación web de Azure App Service denominada app1. App1 usa un plan de servicio basado en el plan de tarifa Básico.
Necesita crear una ranura de implementación para app1.
¿Qué debe hacer primero?
    - Escale verticalmente app1.

    Este elemento pone a prueba los conocimientos de los candidatos sobre la creación de ranuras de implementación, lo que se vincula directamente al plan de tarifa que usan las aplicaciones web de Azure App Service. Esto se configura como parte de la creación de aplicaciones web de Azure App Service.
    Las ranuras de implementación requieren como mínimo el plan de tarifa Estándar, por lo que para proporcionar compatibilidad con app1, es necesario el escalado vertical. El escalado horizontal de app1 aprovisiona más instancias de app1, pero no proporciona la capacidad de crear su ranura de implementación. La implementación automatizada de app1 con Azure DevOps o GitHub no es un requisito previo de compatibilidad con ranuras de implementación, pero normalmente es la razón para implementarlas.


1. Debe configurar una aplicación web para permitir solicitudes externas desde https://myapps.com.
¿Qué comando de la CLI de Azure debe ejecutar?
    - az webapp cors add -g MyResourceGroup -n MyWebApp --allowed-origins https://myapps.com

    Este elemento pone a prueba los conocimientos de los candidatos sobre la configuración de aplic. web.
    El segmento de código que incluye cors add permitirá configurar CORS para habilitar solicitudes de HYPERLINK "https://myapps.com" https://myapps.com. El segmento de código que incluye identity add permitirá agregar una identidad administrada a una aplicación web. El segmento de código que incluye traffic-routing-set permitirá configurar un enrutamiento de tráfico a una ranura de implementación denominada myapps. El segmento de código que incluye access-restriction add permitirá agregar una restricción de acceso en una aplicación web.


1. Administra una implementación de varias instancias de una aplicación web de Azure App Service denominada app1.
Es necesario asegurarse de que una aplicación cliente se enrute a la misma instancia durante la vida útil de la sesión.
¿Qué configuración de plataforma debería usar?
    - Afinidad ARR

    Este elemento pone a prueba los conocimientos de los candidatos sobre la configuración de la aplicación web, lo que forma parte de la creación de Azure App Service Web Apps.
    En una implementación de varias instancias, la configuración afinidad de ARR garantizará que una aplicación cliente se enrute a la misma instancia durante la vida útil de la sesión. WebSocket es un protocolo normalizado que proporciona comunicación de dúplex completo. Always On mantendrá la aplicación cargada incluso cuando no haya tráfico. En HTTP/2, se puede usar una conexión persistente para atender varias solicitudes simultáneas. Las versiones de WebSocket, Always On y HTTP no se usan para asegurarse de que una aplicación cliente se enrute a la misma instancia durante la vida útil de la sesión.


1. Tiene previsto crear una aplicación de Azure Functions denominada app1.
Debe asegurarse de que app1 cumpla con los siguientes requisitos:
Admite el escalado automático.
Tiene un comportamiento de escalado basado en eventos.
Proporciona un modelo de precios sin servidor.
¿Qué plan de hospedaje debería usar?
    - Consumo

    Este elemento pone a prueba los conocimientos de los candidatos sobre la selección del plan de hospedaje adecuado, lo que forma parte de la implementación de Azure Functions.
    El plan de hospedaje Consumo cumple todos los requisitos. Admite el escalado automático, tiene un comportamiento de escalado basado en eventos y proporciona un modelo de precios sin servidor. Los planes de hospedaje App Service, App Service Environment y Functions Premium admiten el escalado automático, pero no proporcionan el modelo de precios sin servidor. Su comportamiento de escalado no se basa en eventos, sino en el rendimiento.


1. Tiene una instancia de Azure Key Vault denominada MyVault.
Debe cambiar la configuración de Azure App Service mediante una referencia del almacén de claves para acceder a un secreto denominado MyConnection en MyVault.
¿Qué segmento de código debería usar?
    - @Microsoft.KeyVault(SecretName=MyConnection;VaultName=MyVault)

    Este elemento pone a prueba los conocimientos de los candidatos sobre la recuperación de secretos de Key Vault en Azure Functions.
    El segmento de código @Microsoft.KeyVault(SecretName=MyConnection;VaultName=MyVault) lee el secreto de Key Vault. El segmento de código que incluye Secret utiliza un parámetro no válido. El segmento de código que incluye Secret y Vault utiliza parámetros no válidos. El segmento de código que incluye SecretName y Vault utiliza parámetros no válidos.


1. Desarrolla una aplicación de App Service hospedada en la Plataforma Windows. Los usuarios notifican que se produce un error en la aplicación.
Es necesario comenzar a solucionar problemas de la aplicación inspeccionando una copia de la página que se devuelve cuando el código de retorno HTTP sea mayor que 400.
¿Qué tipo de registro debería revisar?
    - error detallado

    Este elemento pone a prueba los conocimientos de los candidatos sobre el uso de registros para solucionar problemas de aplicaciones web. El registro de errores detallado contiene copias de las páginas de error, generadas en respuesta a códigos HTTP superiores a 400, que se habrían enviado a los clientes. Estas páginas no se envían debido a motivos de seguridad. El registro del servidor web muestra información sobre las solicitudes HTTP sin procesar, como el método, los bytes y el agente de usuario cliente. El registro de aplicaciones es específico de la aplicación, que registra la información que escribe el código o los componentes de la aplicación que usa la aplicación. El registro de implementación almacena información para diagnosticar los motivos de tener implementaciones con errores.


1. Está desarrollando una aplicación de Azure Functions que se implementará en un plan dedicado.
Cuando haya escasez de recursos en la aplicación, deberá enviar una respuesta “429 demasiado ocupada”.
Es necesario aplicar la configuración adecuada a todas las funciones de una instancia de aplicación de Azure Functions.
¿Qué configuración debería establecer?
    - dynamicThrottlesEnabled en el archivo host.json

    Este elemento pone a prueba los conocimientos de los candidatos sobre el control de escalado de funciones. El uso de la propiedad dynamicThrottlesEnabled permite a los desarrolladores permitir que el sistema responda dinámicamente a un mayor uso, devolviendo errores “429 Demasiado ocupado”. Esta propiedad se define en el archivo host.json. La sección enlaces, que es parte del archivo function.json, se usa para definir los enlaces y desencadenadores de una función. La propiedad maxConcurrentRequests se usa para determinar el número máximo de instancias de función que se van a ejecutar en paralelo. Se define en el archivo function.json. La propiedad maxOutstandingRequests, definida en el archivo host.json, define el número máximo de solicitudes, en cola o en curso, que se mantienen en cualquier momento dado.


1. Administra API en producción mediante Azure API Management.
Debe quitar los encabezados X-Powered-By y X-AspNet-Version de una respuesta.
¿Qué segmento de código debería usar?
    - <policies> <inbound> <base /> </inbound> <backend> <base /> </backend> <outbound> <set-header name="X-Powered-By" exists-action="delete" /> <set-header name="X-AspNet-Version" exists-action="delete" /> <base /> </outbound> <on-error> <base /> </on-error> </policies>

    Este elemento pone a prueba los conocimientos de los candidatos sobre la definición de directivas para las API mediante Azure API Management.
    El segmento de código que incluye el elemento de política set-header en la sección de salida y exists-action="delete" permitirá eliminar un encabezado de la respuesta HTTP. El segmento de código que incluye exists-action con el valor append no permitirá quitar los encabezados indicados. Los segmentos de código que no incluyen el elemento de política set-header en la sección de salida no permitirán quitar un encabezado de la respuesta HTTP.


1. Tiene un centro de eventos de Azure.
Debe agregar particiones al centro de eventos.
¿Qué segmento de código debería usar?
    - az eventhubs eventhub update --resource-group MyResourceGroupName --namespace-name MyNamespaceName --name MyEventHubName --partition-count 12

    Este elemento pone a prueba los conocimientos de los candidatos sobre el desarrollo de soluciones basadas en eventos.
    El segmento de código que incluye az eventhubs eventhub update agrega particiones a un centro de eventos existente. El segmento de código que incluye az eventhubs eventhub consumer-group update actualiza el grupo de consumidores del centro de eventos. El segmento de código que incluye az eventhubs eventhub consumer-group create crea un grupo de consumidores del centro de eventos. El segmento de código que incluye el segmento az eventhubs eventhub create --resource-group creará un centro de eventos con particiones, no cambiará uno existente


1. Debe establecer una duración de 10 segundos para una clave almacenada en Azure Cache for Redis.
¿Qué segmento de código debería usar?
    - using (var cache = ConnectionMultiplexer.Connect("")) { IDatabase db = cache.GetDatabase(); bool setValue = await db.StringSetAsync("test:key", "10", TimeSpan.FromSeconds(10)); }

    Este elemento prueba los conocimientos de los candidatos sobre la implementación del almacenamiento en caché.
    El segmento de código que incluye TimeSpan.FromSeconds(10)); establece el período de vida de 10 segundos para una clave. Para establecer el período de vida de una clave, es necesario especificar el parámetro ‘expiry’ (tercer parámetro) de StringSet métodos. El período de vida debe establecerse como TimeSpan, no como DateTime.


1. Tiene previsto permitir que un usuario cree una identidad administrada para una máquina virtual (VM) de Azure.
Deberá asegurarse de que se cumplan los siguientes requisitos:
La cuenta de usuario debe tener permisos suficientes para crear la identidad administrada.
Debe usarse el principio de privilegios mínimos.
¿Qué rol de permisos debería asignar?
    - Colaborador de la máquina virtual

    Este elemento pone a prueba los conocimientos de los candidatos sobre el principio de privilegios mínimos, que es una parte esencial de la implementación de soluciones seguras en la nube.
    Colaborador de máquina virtual es el rol integrado con menos privilegios que se necesita para crear una identidad administrada para una máquina virtual de Azure. El inicio de sesión del administrador de máquinas virtuales no es suficiente para crear una identidad administrada para una máquina virtual de Azure. El administrador global y el administrador de seguridad tienen permisos excesivos para Microsoft Entra ID, algo que no sigue el principio de privilegios mínimos. El administrador global y el administrador de seguridad no proporcionan permisos suficientes para los recursos de Azure.


1. Debe agrupar claves en Azure App Configuration.
¿Cuáles son dos formas posibles de lograr este objetivo? Cada respuesta correcta presenta una solución completa.
    - Organice las claves mediante prefijos de clave.
    - Organice las claves mediante etiquetas.

    Este elemento pone a prueba los conocimientos de los candidatos sobre los procedimientos recomendados al trabajar con claves en Azure App Configuration.
    Los prefijos de clave son lo que va al principio de la clave. Se puede agrupar un conjunto de claves con el mismo prefijo en los nombres. Las etiquetas son un atributo en las claves. Las etiquetas se usan para crear variantes de una clave. Por ejemplo, las etiquetas se podrían asignar a varias versiones de una clave. La autorización del control de acceso basado en roles para leer Azure App Configuration no es una manera válida de agrupar claves. La autorización de una identidad administrada para leer Azure App Configuration no es una manera válida de agrupar claves.


1. Tiene un contenedor de cuentas de Azure Storage denominado container1.
Debe configurar el acceso al contenedor para cumplir con los siguientes requisitos:
El token de firma de acceso compartido (SAS) debe protegerse con las credenciales de Microsoft Entra ID.
Debe usarse el Control de acceso basado en roles (RBAC).
El token de SAS debería admitir la concesión de acceso a los contenedores.
¿Qué tipo de SAS debería usar?
    - delegación de usuarios

    Este elemento pone a prueba los conocimientos de los candidatos sobre la protección de una cuenta de Azure Storage, que forma parte del desarrollo de soluciones que usan Blob Storage.
    La SAS de delegación de usuarios cumple todos los requisitos, incluyendo la protección del token de SAS con credenciales de Microsoft Entra ID, la compatibilidad con RBAC y la concesión de acceso a contenedores. Azure Storage admite la creación de un nuevo tipo de SAS en el nivel de la cuenta de almacenamiento. Una SAS de servicio delega el acceso a un recurso en solo uno de los servicios de almacenamiento (es decir, Blob, Cola, Tabla o Archivo). Una directiva de acceso almacenada sirve para agrupar firmas de acceso compartido y proporcionar restricciones adicionales para las firmas sujetas a la directiva. Los tipos de SAS de directiva de acceso almacenado, servicio y cuenta no cumplen con el requisito de proteger el token de SAS con credenciales de Microsoft Entra ID y la compatibilidad con RBAC para administrar permisos.


1. Tiene la tarea de mejorar la seguridad de una aplicación web de Azure existente. Actualmente, la aplicación almacena datos de configuración confidenciales, como cadenas de conexión y claves de API en el código, lo que ha generado problemas de seguridad.
Debe proteger los datos de configuración de la aplicación para evitar el acceso no autorizado y posibles filtraciones de datos, a la vez que garantiza un acceso sin problemas para la propia aplicación.
¿Con qué dos opciones se puede lograr este objetivo? (Elija dos).
    - Migre los datos de configuración confidenciales a Azure Key Vault y use identidades administradas para acceder de forma segura a los secretos.
    - Almacene los datos de configuración confidenciales en Azure App Configuration y restrinja el acceso mediante el control de acceso basado en roles (RBAC) de Azure.

    El almacenamiento de datos de configuración confidenciales en Azure App Configuration y la restricción del acceso con Azure RBAC es un método seguro para administrar la configuración de la aplicación y tener el control sobre quién puede acceder a los datos. La migración de datos confidenciales a Azure Key Vault y el uso de identidades administradas permite a la aplicación autenticarse en servicios que admiten la autenticación de Azure AD, sin necesidad de usar credenciales en el código, lo que mejora la seguridad. El cifrado de los datos y su almacenamiento dentro del código de la aplicación no sigue los procedimientos recomendados de seguridad, ya que todavía residirían en el código base y podrían quedar expuestos. El almacenamiento de datos confidenciales en un repositorio privado de GitHub no es seguro, ya que se basarían en las credenciales de GitHub, lo que, si están en peligro, podrían producirse accesos no autorizados.


1. Crea una aplicación web de Azure de forma local. La aplicación web consta de un paquete ZIP.
Necesita implementar la aplicación web mediante la CLI de Azure. La implementación debe reducir la probabilidad de bloqueo de archivos.
¿Qué debería hacer?
    - Ejecute az webapp deploy en un espacio de ensayo con intercambio automático.

    Este elemento pone a prueba los conocimientos de los candidatos sobre la implementación de Azure Web Apps mediante la CLI de Azure.
    El uso de una ranura de producción y almacenamiento provisional con intercambio automático habilitado reducirá la probabilidad de tener archivos bloqueados. Si se usa –clean true, se limpiará la carpeta de destino, pero esto no afectará a la probabilidad de tener archivos bloqueados. Es bueno reiniciar la aplicación después de la implementación. Sin embargo, este es el comportamiento predeterminado de una implementación ZIP y no tiene ningún efecto en reducir la probabilidad de tener archivos bloqueados durante la implementación. El parámetro --timeout no tiene ningún efecto en la probabilidad de tener archivos bloqueados.


1. Necesita implementar un recurso compartido de Azure Files junto con un grupo de contenedores en Azure Container Instances (ACI).
¿Qué método de implementación debería usar?
    - Plantilla del Administrador de recursos de Azure

    Este elemento pone a prueba los conocimientos de los candidatos de la ejecución de contenedores mediante Azure Container Instances (ACI). Hay dos maneras comunes de implementar un grupo de varios contenedores: usar una plantilla de Azure Resource Manager o un archivo YAML. Se recomienda usar una plantilla de Azure Resource Manager cuando se necesiten implementar recursos adicionales de un servicio de Azure (por ejemplo, un recurso compartido de Azure Files) al implementar instancias de contenedor. Sin embargo, un archivo YAML no admite la implementación de recursos de servicio de Azure adicionales junto con grupos de contenedores en ACI. Docker Compose y la CLI de Azure no admiten la implementación de un recurso compartido de Azure Files junto con un grupo de contenedores en ACI.


1. Administra la implementación de instancias de Azure Container Registry denominada registry1 para una empresa.
Debe asegurarse de que registry1 se pueda compartir entre varios grupos de la empresa, lo que permitirá el aislamiento de grupos.
¿Qué debe usar?
    - espacio de nombres

    Este elemento pone a prueba los conocimientos de los candidatos sobre la publicación de imágenes en Azure Container Registry. Un repositorio es una colección de imágenes de contenedor u otros artefactos de un registro que tienen el mismo nombre, pero etiquetas diferentes. Un espacio de nombres permite identificar los repositorios relacionados y la propiedad del artefacto mediante nombres delimitados por barra diagonal. Una etiqueta para una imagen especifica su versión. Un artefacto puede ser, por ejemplo, un archivo de texto, una imagen de Docker o un gráfico de Helm almacenado en el registro con una o varias etiquetas. Las imágenes de contenedor constan de capas. Las capas se usan para evitar la transferencia de información redundante y omitir los pasos de compilación que no hayan cambiado.


1. Una empresa tiene una aplicación web de App Service que requiere un certificado TLS/SSL. El certificado se usará en otras aplicaciones de App Service. El certificado se deberá renovar automáticamente con la sobrecarga de administración mínima.
Es necesario agregar el certificado.
¿Qué tiene que hacer?
    - Compra de un certificado de App Service.

    Este elemento pone a prueba los conocimientos de los candidatos sobre la configuración de la aplicación web, como SSL, la configuración de API y las cadenas de conexión. La compra de un certificado de App Service automatiza los procesos de solicitud, renovación y sincronización del certificado con las aplicaciones de App Service que los usan. Los certificados gratuitos de App Service ofrecen funcionalidades básicas y no se pueden exportar. Obtener el certificado de un tercero y cargarlo en Azure App Service también es una opción, pero carece de la automatización e integración que ofrecen los certificados de App Service. Se recomienda almacenar certificados en un almacén de claves y recuperarlos. En cambio, si se obtienen de un tercero, será necesario automatizar la renovación y la sincronización con las aplicaciones de App Service de otras formas.


1. Está desarrollando una aplicación de Azure Functions que se implementará en un plan de consumo. La aplicación consume datos de un servidor de bases de datos que tiene un rendimiento limitado.
Debe usar la propiedad functionAppScaleLimit para controlar el número de instancias de la aplicación que se crearán.
¿Qué valor debería usar para la configuración de la propiedad?
    - 10

    Este elemento pone a prueba los conocimientos sobre la configuración de una aplicación de Azure Functions. Imponer límites en la capacidad de escalado horizontal de una aplicación de Azure Functions podría ayudar cuando la aplicación se conecte a los componentes que tengan un rendimiento limitado. La propiedad functionAppScaleLimit le permite definir el número de instancias que se creará de la aplicación Azure Functions. Por lo tanto, establecerlo en un valor bajo, como 10, resulta adecuado en este escenario. Las aplicaciones de Azure Functions del plan de consumo pueden escalar horizontalmente y tener 200 instancias como valor predeterminado. Un valor de 0 o null para la propiedad functionAppScaleLimit significa que se creará un número sin restricciones de instancias de la aplicación de Azure Functions.


1. Su empresa está desarrollando una aplicación que incluye un servicio de API web de backend. El equipo de desarrollo ha decidido usar Azure Container Apps para hospedar la API. Tienen un Dockerfile en la raíz del repositorio que define la aplicación en contenedores.
Debe implementar la aplicación contenedora mediante Dockerfile.
¿Qué tiene que hacer?
    - Use el comando az containerapp up con el parámetro --source ..

    El comando az containerapp up con el parámetro --source . compila e implementa la aplicación contenedora mediante Dockerfile en la raíz del repositorio. Las otras opciones no existen o no cumplen el requisito.


1. Administra una base de datos de Azure Cosmos DB denominada database1.
Es necesario leer elementos de la base de datos sin ninguna garantía de ordenación y garantizar la máxima disponibilidad.
¿Qué nivel de coherencia debería usar?
    - Posible

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de coherencia en Azure Cosmos DB, que forma parte del desarrollo de soluciones que usan el almacenamiento de Azure Cosmos DB.
    La coherencia final tiene la coherencia más flexible y confirma cualquier operación de escritura en la principal inmediatamente. Esto proporcionará la disponibilidad más alta y la coherencia más baja. La coherencia fuerte ofrece una garantía de linearización. La linearización hace referencia a la capacidad de servir solicitudes simultáneamente. Se garantiza que los usuarios siempre leerán la escritura confirmada más reciente. Una coherencia fuerte sufrirá de disponibilidad reducida. La coherencia de obsolescencia limitada no proporcionará la máxima disponibilidad. Cuando un cliente realiza operaciones de lectura dentro de una región que acepta escrituras, las garantías proporcionadas por la coherencia de obsolescencia limitada y la coherencia fuerte serán idénticas. La coherencia de la sesión garantizará que en una sesión de usuario todas las operaciones de lectura y escritura sean coherentes. Dado que la aplicación no requiere garantía de coherencia, este nivel de coherencia no es adecuado.


1. Tiene una directiva de ciclo de vida de Azure Storage para blobs en bloques.
Es necesario crear una regla de filtro prefixMatch que contendrá una matriz de cadenas para que coincidan los prefijos.
¿Cuál debería ser el primer elemento de la cadena de prefijo?
    - un nombre de contenedor

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo configurar el filtro prefixMatch, lo que es una parte esencial de la configuración de la directiva de almacenamiento y forma parte del desarrollo de soluciones para Blob Storage.
    Al crear una regla de filtro prefixMatch para una directiva de ciclo de vida de Azure Storage para blobs en bloques, el primer elemento de la cadena de prefijo deberá ser un nombre de contenedor, no una etiqueta de índice de blobs en bloques, un nombre de blob en bloques o un nombre de cuenta de almacenamiento.


1. Crea la siguiente directiva de retención. (Los números de línea solo se incluyen como referencia).

```java
 1  {
 2    "rules": [
 3      {
 4        "name": "agingRule",
 5        "enabled": true,
 6        "type": "Lifecycle",
 7        "definition": {
 8          "filters": {
 9            "blobTypes": [ "blockBlob" ],
10           "prefixMatch": [ "sample-container/blob1" ]
11         },
12         "actions": {
13           "baseBlob": {
14
15           }
16         }
17       }
18     }
19   ]
20 }
```

Será necesario realizar la transición de blobs en el nivel de acceso frecuente a un nivel en línea si los blobs no se han modificado en más de 90 días.
¿Qué segmento de código debería agregar a la línea 14?

    - "tierToCool": { "daysAfterModificationGreaterThan": 90 }

    ```java
    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de blob.
    El segmento de código "tierToCool": { "daysAfterModificationGreaterThan": 90 } moverá los blobs no modificados después de 90 días al nivel de acceso esporádico, tal y como se define en el requisito. Segmentos de código que incluyen "tierToArchive": mueven los blobs al nivel de archivo, que no es un nivel de acceso en línea, sino un nivel sin conexión. El segmento de código "tierToCool": { "daysAfterCreationGreaterThan": 90 } mueve los blobs al nivel de acceso esporádico 90 días después de la creación, lo que no cumple con el requisito de mover blobs después de 90 días sin modificaciones.
    ```


1. Una empresa tiene un blob en el nivel de acceso de archivo.
Es necesario rehidratar el blob a un nivel en línea.
¿Cuáles son dos formas posibles de lograr este objetivo? Cada respuesta correcta presenta una solución completa.
    - Copie el blob en un nuevo blob en el nivel Frecuente o Esporádico con la operación Copiar blob.
    - Cambie el nivel del blob mediante la operación Establecer nivel de blob.

    Este elemento pone a prueba los conocimientos de los candidatos sobre el desarrollo de soluciones que usen Blog Storage.
    La operación Copiar blob copia un blob en un nivel en línea. La operación Establecer nivel de blob establece el nivel de acceso en un blob. La operación Establecer propiedades de blob establece las propiedades del sistema en el blob. La operación Instantánea de blob crea una instantánea de solo lectura de un blob.


1. Es necesario implementar una directiva de ciclo de vida de Azure Storage para blobs anexos.
¿Qué acción de regla debería usar?
    - delete

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo configurar la directiva de ciclo de vida de Azure Storage para blobs, que es una parte esencial del desarrollo de soluciones para Blob Storage.
    La acción eliminar regla admite blobs en bloques y blobs anexos. Las acciones de regla enableAutoTierToHotFromCool, tierToArchive y tierToCool solo admiten blobs en bloques.


1. Una empresa implementa una cuenta de Azure Cosmos DB de varias regiones.
Deberá configurar el nivel de coherencia predeterminado para la cuenta. El nivel de coherencia deberá asegurarse de que las operaciones de actualización realizadas como un lote dentro de una transacción siempre estén visibles juntas.
¿Qué nivel de coherencia debería usar?
    - De prefijo coherente

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo seleccionar el nivel de coherencia adecuado para las operaciones en Azure Cosmos DB. El nivel de coherencia de prefijo coherente garantiza que las actualizaciones hechas como un lote dentro de una transacción se devuelvan constantemente con la transacción en la que se confirmaron. Las operaciones de escritura dentro de una transacción de varios documentos siempre están visibles juntas. El nivel de coherencia Obsolescencia limitada se usa para administrar el retraso de los datos entre dos regiones en función de una versión actualizada de un elemento o los intervalos de tiempo entre lectura y escritura. El nivel de coherencia Sesión se usa para garantizar que, en una sesión de cliente individual, las lecturas respeten las garantías de lectura de las escrituras y escritura tras las lecturas. El nivel de coherencia Eventual se usa cuando no se requiere ninguna garantía de ordenación.


1. Una empresa implementa una cuenta de Azure Cosmos DB denominada Account1 para almacenar detalles de productos.
Deberá escribir una consulta SQL parametrizada para obtener elementos del contenedor Productos, en función de los parámetros de categoría y precio.
¿Qué consulta SQL debería escribir?
    - SELECT * FROM Products p WHERE p.category = @Category AND p.price = @Price

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo realizar operaciones en contenedores y elementos mediante el SDK. Azure Cosmos DB admite consultas SQL con parámetros que se expresen con la notación @. Al escribir consultas SQL basadas en parámetros, es necesario mencionar el nombre del contenedor en la cuenta de Azure Cosmos DB. No usamos [accountname].[containername] o, simplemente, [accountname] en la consulta SQL. Incluir el nombre del parámetro entre comillas simples no es el formato correcto.


1. Fabrikam, Inc. está realizando un estudio jurídico y necesita asegurarse de que determinados documentos confidenciales almacenados en Azure Blob Storage no se puedan modificar ni eliminar hasta que se finalice el estudio.
Debe implementar una directiva de inmutabilidad que se pueda aplicar temporalmente y quitar una vez finalizado el estudio.
¿Qué tiene que hacer?
    - Configure una directiva de suspensión legal en el contenedor donde se almacenan los documentos.

    La configuración de una directiva en suspensión legal en el contenedor permite proteger los documentos para que no se modifiquen ni se eliminen hasta que se retire expresamente la suspensión. Una directiva de retención basada en el tiempo con un intervalo fijo no aporta la flexibilidad necesaria para una suspensión temporal. En este caso no es necesario habilitar el control de versiones ni configurar una directiva de retención basada en el tiempo que afecte a las versiones. Una directiva WORM de nivel de contenedor con un intervalo de retención fijo no cumple el requisito.


1. Administra un centro de eventos de Azure.
Debe asegurarse de que se puedan usar varias instancias de carga equilibrada de una aplicación .NET (versión 5.0) para escalar el procesamiento de eventos.
¿Qué cliente de procesador de eventos debería usar?
    - EventProcessorClient

    Este elemento pone a prueba los conocimientos de los candidatos sobre el escalado de aplicaciones de procesamiento de eventos, que forma parte del desarrollo de soluciones basadas en eventos.
    EventProcessorClient equilibra la carga entre varias instancias de un programa en versiones más recientes de .NET (versión 5.0). EventHubConsumerClient equilibra la carga entre varias instancias de un programa en Python y JavaScript. EventProcessorHost equilibra la carga entre varias instancias de un programa en versiones anteriores de .NET. La clase EventHubProducerClient se usa para enviar eventos a un centro de eventos.


1. Debe capturar el streaming de eventos desde Azure Event Hubs.
¿En qué tres ubicaciones puede obtener los datos? Cada respuesta correcta presenta una solución completa.
    - Azure Blob Storage
    - Azure Data Lake Storage Gen1
    - Azure Data Lake Storage Gen2

    Este elemento pone a prueba los conocimientos de los candidatos sobre la implementación de soluciones que usen Azure Event Hubs.
    Capture, de Azure Event Hubs, puede entregar automáticamente los datos de streaming en Event Hubs a Azure Blob Storage. Capture, de Azure Event Hubs, puede entregar automáticamente los datos de streaming en Event Hubs a Azure Data Lake Storage Gen1. Capture, de Azure Event Hubs, puede entregar automáticamente los datos de streaming en Event Hubs a Azure Data Lake Storage Gen2. Azure Functions y Azure Stream Analytics no se pueden usar para capturar eventos de Azure Event Hubs.


1. Tiene una cola de Azure Service Bus.
Debe asegurarse de que un publicador pueda enviar mensajes a un tema y de que varios suscriptores puedan ser aptos para consumir los mensajes.
¿Qué patrón de enrutamiento de mensajes debería usar?
    - solicitud/respuesta de multidifusión

    Este elemento pone a prueba los conocimientos de los candidatos sobre el enrutamiento de mensajes en Azure Service Bus, que forma parte del desarrollo de soluciones basadas en mensajes.
    Un publicador puede enviar mensajes a un tema y varios suscriptores pueden ser aptos para consumir los mensajes. Un publicador puede enviar un mensaje a una cola y esperar una respuesta del consumidor de mensajes, pero varios suscriptores no pueden consumir el mensaje. Esta característica de sesión permite la multiplexación de secuencias de mensajes relacionados a través de una sola cola, pero no se puede consumir por varios suscriptores. Esta característica de sesión permite respuestas multiplexadas, lo que permite que varios publicadores compartan una cola de respuestas, pero que varios suscriptores no puedan consumir un mensaje.


1. Está desarrollando un proyecto de .NET que administrará mensajes en colas de Azure Storage.
Debe comprobar la presencia de mensajes en una cola sin quitarlos de la cola.
¿Qué método usaría?
    - PeekMessages

    Este elemento pone a prueba los conocimientos de los candidatos sobre el proceso de mensajes en Azure Queue Storage, que es una parte integral de la implementación de soluciones que usen colas de Azure Queue Storage.
    Los mensajes se pueden ver en la cola sin quitarlos de la misma llamando al método PeekMessages de la clase QueueClient. El método Peek de la clase QueueClient se usa con Azure Service Bus, no con Azure Queue Storage. El método ReceiveMessages de la clase QueueClient los quita de la cola. El método ReceiveMessageAsync de la clase QueueClient se usa con Azure Service Bus, no con Azure Queue Storage.


1. Una empresa está desarrollando una solución basada en IoT para edificios inteligentes que recopila datos de telemetría de varios sensores. Los datos se envían a Azure para el análisis y el almacenamiento en tiempo real.
Debe implementar una solución que permita la ingesta de grandes volúmenes de eventos y permite una distribución fiable en los servicios de procesamiento final con una latencia mínima.
¿Qué servicio debe usar?
    - Azure Event Hubs

    Azure Event Hubs está diseñado para la transmisión de eventos en tiempo real de alto rendimiento y es compatible con Apache Kafka, por lo que es perfecto para entornos basados en IoT. Azure Event Grid es más adecuado para el enrutamiento de eventos y aplicaciones sin servidor. Azure Service Bus es mejor para los patrones tradicionales de mensajería empresarial y Azure Blob Storage no está optimizado para la ingesta de eventos en tiempo real.


1. Una empresa usa Azure Event Grid para procesar eventos de pedidos en el ámbito del comercio electrónico. El sistema incluye varios orígenes de eventos, como Azure Blob Storage, Azure Functions y servicios de terceros. La empresa quiere asegurarse de que el mecanismo de distribución de eventos es sólido y puede controlar diferentes contextos de errores con una pérdida mínima.
Debe diseñar una estrategia de distribución de eventos que garantice una alta fiabilidad, aun cuando los eventos se derivan de códigos de respuesta 400 o 413.
¿Qué tiene que hacer?
    - Habilite la entrega de mensajes fallidos para obtener eventos que no se entreguen según la planificación de reintentos correspondiente.

    Si se habilita la cola de mensajes fallidos, podrá capturar eventos que no se pueden entregar dentro de la programación de reintentos especificada, lo que garantiza que no se pierdan datos durante interrupciones temporales. Si se aumenta el número máximo de intentos de entrega, esta no está garantizada si el sistema está inactivo y esto puede conllevar retrasos innecesarios. La validación sincrónica del protocolo de enlace está relacionada con la validación de suscripciones, no con la fiabilidad de la entrega de eventos. Si el sistema no está disponible de forma temporal, la disminución del TTL (período de vida) de los evento podría dar lugar a que se quiten eventos válidos.


1. Administra una instancia de Azure API Management. Las directivas se definen en varios ámbitos.
Debe aplicar un orden de evaluación de directivas.
¿Qué debe usar?
    - el elemento <base/>

    Este elemento pone a prueba los conocimientos de los candidatos sobre la definición de directivas para las API.
    El elemento proporciona la capacidad de aplicar el orden de evaluación de directivas. El elemento forma parte de la directiva choose y se evalúa en orden de apariencia dentro de la directiva. El atributo follow-redirects forma parte de la política de solicitud de reenvío, por lo que no tiene ningún impacto en el orden de evaluación de la política. El atributo condition forma parte de la directiva de reintentos, por lo que no tiene ningún impacto en el orden de evaluación de la directiva.


1. 
    -


1. 
    -


1. 
    -


1. 
    -


1. 
    -


1. 
    -


1. 
    -


1. 
    -


1. 
    -


1. 
    -


1. 
    -


1. 
    -