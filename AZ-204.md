# Desarrollo de soluciones para Microsoft Azure

1. Una empresa planea usar Azure Cache for Redis. La empresa planea usar módulos de Redis. Necesita recomendar un nivel de servicio de Azure Cache for Redis. ¿Qué nivel de servicio tiene que recomendar?
    - Enterprise

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de servicio de Azure Cache for Redis. Los módulos de Redis solo se admiten en el nivel de servicio Enterprise. Los niveles de servicio Básico, Estándar y Premium no admiten módulos de Redis.


1. Usted administra una instancia de Azure Cache for Redis. Necesita cargar datos a petición en la memoria caché desde una base de datos grande. ¿Qué patrón de arquitectura de aplicaciones debería usar?
    - Caché de datos

    Este elemento pone a prueba los conocimientos de los candidatos sobre el patrón de diseño de arquitectura de aplicaciones, que forma parte de la implementación del almacenamiento en caché para las soluciones. Las bases de datos suelen ser demasiado grandes para cargarse directamente en una memoria caché, por lo que es habitual usar el patrón de caché de datos. El almacén de sesiones se usa para almacenar información de sesión de usuarios en lugar de almacenar demasiados datos en una cookie que pueda afectar negativamente al rendimiento. Las transacciones distribuidas permiten que una serie de comandos se ejecuten en un almacén de datos de back-end como una sola operación. Mediante el uso de la caché de contenido, puede proporcionar acceso más rápido al contenido estático en comparación con los almacenes de datos de back-end. El almacén de sesiones, las transacciones distribuidas y la caché de contenido no se pueden usar para cargar datos a petición.


1. Usted administra Azure Cache for Redis mediante clases en el espacio de nombres .NET StackExchange.Redis. Debe recuperar una referencia de una base de datos de Redis mediante el método GetDatabase. ¿Qué debería que hacer en primer lugar?
    - Crear un objeto ConnectionMultiplexer

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo interactuar mediante programación con Azure Cache for Redis, que es una parte integral de la implementación de patrones de caché de aplicaciones seguros y optimizados, incluyendo el ajuste de tamaño de datos, las conexiones, el cifrado y la expiración. La creación de un objeto ConnectionMultiplexer es el primer paso necesario para recuperar una referencia a una base de datos de Redis mediante el método GetDatabase. Se requiere crear un objeto CdnManagementClient cuando se use el almacenamiento en caché de Azure Content Delivery Network, no Azure Cache for Redis. Llamar a un método StringSet permitirá administrar el contenido de una base de datos de Redis, lo que se producirá una vez que el objeto ConnectionMultiplexer y la base de datos se hayan creado. Llamar a un método StringGet permitirá recuperar el contenido de una base de datos de Redis, lo que se producirá una vez que el objeto ConnectionMultiplexer y la base de datos se hayan creado.


1. Tiene previsto usar Azure Cache for Redis como capa de almacenamiento en caché para varias aplicaciones. Tiene los siguientes requisitos: Evitar la pérdida de datos si los nodos están inactivos. Minimizar los costes de almacenamiento. Optimizar el rendimiento. ¿Qué solución debe usar?
    - Persistencia de la base de datos de Redis (RDB) con la característica de eliminación temporal deshabilitada en la cuenta de almacenamiento asociada

    Este elemento pone a prueba los conocimientos de los candidatos sobre la persistencia de datos en Azure Cache for Redis. La persistencia de RDB guarda copias de seguridad en función del intervalo de copia de seguridad configurado con un efecto mínimo en el rendimiento. Deshabilitar la característica de eliminación temporal en una cuenta de almacenamiento implica que Azure Cache for Redis no puede minimizar los costes de almacenamiento mediante la eliminación de los datos de copia de seguridad antiguos. Habilitar la característica de eliminación temporal en una cuenta de almacenamiento implica que Azure Cache for Redis no puede minimizar los costes de almacenamiento mediante la eliminación de los datos de copia de seguridad antiguos. La persistencia de AOF guarda cada escritura en un registro, lo que tiene un efecto significativo en el rendimiento. Deshabilitar y habilitar la característica de eliminación temporal en una cuenta de almacenamiento implica que Azure Cache for Redis no puede minimizar los costes de almacenamiento mediante la eliminación de los datos de copia de seguridad antiguos.


1. Tiene la siguiente clase GameStat:
    ```java
    public class GameStat
    {
        public string Id { get; set; }
        public string Sport { get; set; }
        public DateTimeOffset DatePlayed { get; set; }
        public string Game { get; set; }
        public IReadOnlyList<string> Teams { get; set; }
        public IReadOnlyList<(string team, int score)> Results { get; set; }

        public GameStat(string sport, DateTimeOffset datePlayed, string game, string[] teams, IEnumerable<(string team, int score)> results)
        {
            Id = Guid.NewGuid().ToString();
            Sport = sport;
            DatePlayed = datePlayed;
            Game = game;
            Teams = teams.ToList();
            Results = results.ToList();
        }

        public override string ToString()
        {
            return $"{Sport} {Game} played on {DatePlayed.Date.ToShortDateString()} - " +
                $"{String.Join(',', Teams)}\r\n\t" + 
                $"{String.Join('\t', Results.Select(r => $"{r.team } - {r.score}\r\n"))}";
        }
    }
    ```
    Debe almacenar una instancia de la clase GameStat en Azure Cache for Redis. ¿Qué dos segmentos de código debería usar? Cada respuesta correcta presenta una solución completa.

    - 
    ```java
    var stat = new GameStat("Soccer", new DateTime(2019, 7, 16), "Local Game", new[] { "Team 1", "Team 2" }, new[] { ("Team 1", 2), ("Team 2", 1) }); string serializedValue = System.Text.Json.JsonSerializer.Serialize (stat); bool added = db.StringSet("event:1950-world-cup", serializedValue);
    ```

    - 
    ```java
    var stat = new GameStat("Soccer", new DateTime(2019, 7, 16), "Local Game", new[] { "Team 1", "Team 2" }, new[] { ("Team 1", 2), ("Team 2", 1) }); bool added = db.StringSet("event:1950-world-cup", stat.ToString());
    ```

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo implementar el almacenamiento en caché. Los segmentos de código que incluyen la operación StringSet serializarán y almacenarán correctamente el contenido de la clase GameStat en Azure Cache for Redis. Los segmentos de código que incluyen la operación StringGet no lo harán.


1. Tiene una aplicación web de Azure que ocasionalmente experimenta tiempos de respuesta elevados. Debe recibir una notificación cuando el tiempo de respuesta supere un umbral determinado. ¿Qué tiene que hacer?
    - Implemente alertas y pruebas web de Application Insights

    Application Insights permite crear pruebas web que simulan interacciones de usuario con la aplicación y, a continuación, configuran alertas basadas en los resultados de estas pruebas. Las alertas de Resource Health de Azure Monitor se usan para la supervisión de la infraestructura, no para el rendimiento de las aplicaciones. Azure Service Health proporciona información sobre los problemas del servicio de Azure y el mantenimiento planeado, no sobre el rendimiento de las aplicaciones. Azure Advisor proporciona recomendaciones de procedimientos recomendados, no alertas de rendimiento de aplicaciones.


1. El equipo está desarrollando una nueva característica para una aplicación existente basada en Azure que depende en gran medida en el procesamiento de datos en tiempo real. La característica implica la integración de varios servicios de Azure y API de terceros. Debe crear una estrategia para asegurarse de que la integración de estos servicios no presenta ningún problema de rendimiento ni errores. Debe diseñar la solución de supervisión para detectar y solucionar posibles problemas. ¿Qué tiene que hacer?
    - Use Live Metrics en Application Insights para observar la actividad de la aplicación implementada en tiempo real

    La opción D es correcta porque Live Metrics proporciona observación en tiempo real de la actividad de la aplicación, lo que permite la detección inmediata y la respuesta a los problemas de rendimiento. La opción C es incorrecta, ya que es posible que las comprobaciones nocturnas no sean suficientes para las necesidades de procesamiento de datos en tiempo real. La opción A es incorrecta porque una sola prueba de disponibilidad no proporciona una supervisión completa de todos los servicios integrados. La opción B es incorrecta, ya que la revisión manual de los registros no es eficaz para la supervisión en tiempo real y puede retrasar la respuesta a los problemas.


1. Un equipo de desarrollo usa Application Insights para supervisar su aplicación web implementada en Azure. Han observado discrepancias en las métricas notificadas debido a un gran volumen de telemetría. Debe asegurarse de que las métricas notificadas reflejen con precisión el rendimiento de la aplicación sin verse afectados por el muestreo de telemetría. ¿Qué debería implementar para conseguir este objetivo?
    - Configure Application Insights para usar métricas estándar agregadas previamente para paneles y alertas en tiempo real

    Las métricas estándar agregadas previamente no se ven afectadas por el muestreo de telemetría y proporcionan datos precisos en tiempo real, lo que hace que sean adecuados para paneles y alertas. Aumentar la frecuencia de muestreo o deshabilitar el muestreo por completo aumentaría los costos y es posible que aún no proporcione métricas precisas debido al volumen de datos. La creación de una consulta de Kusto personalizada requeriría un esfuerzo manual y no soluciona el problema del muestreo que afecta a las métricas.


1. Tiene previsto usar Microsoft Graph para recuperar una lista de usuarios en un inquilino de Microsoft Entra ID. Es necesario optimizar los resultados de la consulta. ¿Qué dos opciones de consulta debería usar? Cada respuesta correcta presenta parte de la solución.
    - $filter
    - $select

    Este elemento pone a prueba los conocimientos de los candidatos sobre las opciones de consulta de Microsoft Graph La opción de consulta $filter debe usarse para limitar los resultados devueltos. La opción de consulta $select limita los atributos proyectados desde el conjunto de resultados, lo que hace que la consulta sea más eficaz. La opción de consulta $count está pensada para recuperar el recuento total de recursos coincidentes. La opción de consulta $expand se usa para recuperar recursos relacionados.


1. Tiene una cuenta de Azure Storage. Es necesario proporcionar a los usuarios externos la capacidad de crear y actualizar blobs. ¿Qué valor de enumeración de BlobSasPermissions debería usar?
    - Escribir

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo crear e implementar blobs. El permiso de escritura permitirá a los usuarios crear y actualizar blobs. El permiso Agregar solo es aplicable a blobs anexos. El permiso Crear solo permite a los usuarios crear blobs. No permite a los usuarios actualizar blobs. El permiso de lectura no permite a los usuarios crear y actualizar blobs.


1. Administra una aplicación web de Azure App Service denominada app1. App1 se registra como una aplicación multiinquilino en un inquilino de Microsoft Entra ID denominado tenant1. Debe conceder a app1 el permiso para acceder a Microsoft Graph API en tenant1.¿Qué entidad de servicio debería usar?
    - application

    Este elemento pone a prueba los conocimientos de los candidatos sobre el acceso a los datos de usuario desde Microsoft Graph, que forma parte de la implementación de la autenticación y autorización del usuario. Una aplicación de Microsoft Entra ID se define por su único objeto de aplicación, que reside en el inquilino de Microsoft Entra ID donde se registró la aplicación, (conocido como inquilino "principal" de la aplicación). La entidad de servicio de la aplicación se usa para configurar el permiso de app1 en tenant1 para acceder a Microsoft Graph API. La entidad de servicio heredada es una aplicación heredada (la que se ha creado antes de que se introdujeran o crearan registros de aplicaciones mediante experiencias heredadas). Las identidades administradas eliminan la necesidad de administrar las credenciales en el código. Solo hay una identidad administrada asignada por cada recurso y está asociada al ciclo de vida del recurso. Las identidades administradas para los recursos de Azure eliminan la necesidad de administrar las credenciales en el código. Una identidad administrada asignada por el usuario se puede crear y asignar a una o varias instancias de un servicio de Azure. La identidad administrada asignada por el usuario y la identidad administrada asignada por el sistema heredadas no se pueden usar para asignar permisos para app1 en tenant1 para acceder a Microsoft Graph API.


1. Desarrolla una aplicación. Un proveedor tendrá acceso a la aplicación. El proveedor requiere una firma de acceso compartido (SAS) para acceder a los servicios de Azure en su suscripción de la empresa. Debe proteger la SAS. ¿Qué tres acciones debe realizar? Cada respuesta correcta presenta una solución completa.
    - Use siempre HTTPS
    - Use registros de Azure Monitor y Azure Storage para supervisar la aplicación
    - Defina una directiva de acceso almacenada para una SAS de servicio

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo implementar firmas de acceso compartido (SAS). La recomendación de usar siempre HTTPS es válida y debería seguirse. Azure Monitor y el registro de Storage Analytics deberían usarse para observar cualquier pico en estos tipos de errores de autorización. Las directivas de acceso almacenadas le ofrecerán la posibilidad de revocar permisos para una SAS de servicio sin tener que volver a generar las claves de la cuenta de almacenamiento. Un procedimiento recomendado de seguridad es proporcionar al usuario los privilegios mínimos necesarios. Es mejor usar tiempos de expiración de corto plazo en servicios de SAS ad hoc o cuentas de SAS para que, incluso aunque una SAS estuviera en peligro, solo sería válida durante un tiempo breve.


1. Administra una aplicación registrada de Microsoft Entra ID denominada app1. App1 llama a una API web, que luego llamará a Microsoft Graph. Debe asegurarse de que la identidad del usuario que inició sesión se delegue a través de la cadena de solicitudes. ¿Qué flujo de autenticación debería usar?
    - On-Behalf-Of

    Este elemento pone a prueba los conocimientos de los candidatos sobre el acceso a los datos de usuario desde Microsoft Graph, que forma parte de la implementación de la autenticación y autorización del usuario. Flujo OAuth 2.0 On-Behalf-Of (OBO) se usa cuando una aplicación invoca un servicio o API web, que, a su vez, debe llamar a otro servicio o API web. La idea es propagar la identidad del usuario delegado y los permisos a través de la cadena de solicitudes. La concesión de un código de autorización de OAuth 2.0 se puede usar en aplicaciones que se instalan en un dispositivo para obtener acceso a recursos protegidos, como las API web. El flujo de concesión de credenciales de cliente de OAuth 2.0 permite que un servicio web (cliente confidencial) use sus propias credenciales para autenticarse al llamar a otro servicio web, en lugar de suplantar a un usuario. Implícito es un flujo basado en redirección. El cliente debe ser capaz de interactuar con el agente de usuario del propietario del recurso (normalmente un explorador web). El código de autorización, On-Behalf-Of e Implícito no se pueden usar para delegar el permiso y la identidad del usuario.


1. Desarrolla una aplicación web multiinquilino denominada App1. Tiene previsto registrar App1 con varios inquilinos de Microsoft Entra ID. Deberá identificar la relación entre los objetos de aplicación y las entidades de seguridad asociadas a App1. ¿Qué relación debería identificar?
    - App1 tendrá un único objeto de aplicación y varias entidades de servicio

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo configurar la autenticación de aplicaciones multiinquilino, que es un escenario común al implementar la autenticación. App1 tendrá un único objeto de aplicación y varias entidades de servicio. App1 no tendrá varios objetos de aplicación. varios objetos de aplicación y una sola entidad de servicio, o una sola entidad de servicio.


1. Tiene 10 aplicaciones que se ejecutan en Azure App Service Deberá asegurarse de que las aplicaciones tengan acceso a los elementos almacenados en Azure App Configuration mediante una configuración común. No se deben usar contraseñas ni claves. ¿Qué solución debe usar?
    - Identidad administrada asignada por el usuario

    Este elemento pone a prueba los conocimientos de los candidatos sobre las identidades administradas. Las identidades administradas asignadas por el usuario son una manera de reutilizar permisos entre aplicaciones. Las identidades administradas asignadas por el usuario asocian la identidad administrada a las nuevas aplicaciones, sin claves ni contraseñas. Las identidades administradas asignadas por el sistema usan una nueva identidad para cada aplicación, algo que no cumple con el requisito de configuración común. Una entidad de servicio tiene claves que deben rotarse. El desarrollador no ejecuta la aplicación, por lo que no se puede asumir la identidad del desarrollador.


1. Administra una aplicación web de Azure App Service denominada app1 y una instancia de Azure Key Vault denominada vault1. Debe asegurarse de que app1 puede autenticar y realizar operaciones con vault1 sin administrar la rotación de un secreto. El recurso necesario para implementar la solución debe eliminarse automáticamente cuando se elimina la aplicación. ¿Qué método de autenticación debería usar para app1?
    - Identidad administrada asignada por el sistema

    Este elemento pone a prueba los conocimientos de los candidatos sobre la implementación de Azure Key Vault, que forma parte de la implementación de soluciones de Secure Cloud. Se puede usar una identidad administrada asignada por el sistema para asegurarse de que app1 pueda autenticarse y realizar operaciones con vault1 sin administrar la rotación de secretos. Se puede usar una identidad administrada asignada por el usuario para asegurarse de que app1 pueda autenticarse y realizar operaciones con vault1, pero es necesario administrar la rotación de secretos. Una entidad de servicio y un secreto se pueden usar para autenticarse en el almacén de claves, pero es difícil rotar automáticamente el secreto que se usa para autenticarse en el almacén de claves. Se puede usar una entidad de servicio y un certificado asociado con el acceso al almacén de claves para la autenticación, pero requeriría administrar la rotación de un secreto.


1. Una empresa planea usar Azure App Configuration para las marcas de características en una aplicación.
La empresa tiene los siguientes requisitos de cifrado:
Claves administradas por el cliente
claves protegidas por módulos de seguridad de hardware (HSM)
Debe recomendar niveles de servicio.
¿Qué dos niveles debería recomendar? Cada respuesta correcta presenta parte de la solución.
    - Nivel Estándar de Azure App Configuration
    - Nivel Premium de Azure Key Vault

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de servicio para Azure App Configuration y Azure Key Vault.
    El nivel Estándar de App Configuration debe usarse para que las claves administradas por el cliente se usen en App Configuration. El nivel Premium de Key Vault es necesario para admitir claves protegidas con HSM. El nivel Gratis de App Configuration no permite el uso de claves administradas por el cliente. El nivel Estándar de Key Vault no admite claves protegidas con HSM.


1. Debe generar una nueva versión de una clave almacenada en Azure Key Vault.
¿Qué segmento de código debería usar?
    - az keyvault key rotate --vault-name mykeyvault --name mykey

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo establecer la rotación de claves mediante la CLI de Azure.
    La operación Rotate generará una nueva versión de la clave en función de la directiva de claves. La operación Rotation Policy actualiza la directiva de rotación de una clave del almacén de claves. La operación Purge Deleted Key es aplicable a almacenes o HSM habilitados para eliminación temporal. La operación Set Attributes cambia los atributos especificados de una clave almacenada.


1. Está desarrollando una solución que almacena secretos en una instancia de Azure Key Vault denominada myvault.
Necesita recuperar el valor de un secreto denominado mysecret que se almacena en myvault.
¿Qué comando de la CLI debería usar?
    - az keyvault secret show --name mysecret --vault-name myvault

    Este elemento pone a prueba los conocimientos de los candidatos sobre el desarrollo de código que use claves, secretos y certificados almacenados en Azure Key Vault. El comando de la CLI az keyvault ofrece varios comandos para trabajar con secretos. Los comandos más usados son set para almacenar un secreto y show para obtener el valor del secreto. Al usar estos comandos, debe especificarse un identificador que especifique la identificación de secreto completa (en el formato https://<keyvaultname>.vault.azure.net/secrets/<secret-name>/<secret-version>), o bien el secreto y el nombre del almacén.


1. Debe crear un contenedor en un grupo de contenedores y montar un recurso compartido de archivos de Azure como volumen.
¿Qué segmento de código debería usar?
    - az container create -g MyResourceGroup --name myapp --image myimage:latest --command-line "cat /mnt/azfile/myfile" --azure-file-volume-share-name myshare --azure-file-volume-account-name mystorageaccount --azure-file-volume-account-key mystoragekey --azure-file-volume-mount-path /mnt/azfile

    Este elemento pone a prueba los conocimientos de los candidatos sobre la ejecución de contenedores mediante Azure Container Instances.
    El segmento de código que incluye el parámetro –azure-file-volume-mount-path y el parámetro --azure-file-volume-share-name crea un contenedor en un grupo de contenedores y monta un recurso compartido de archivos de Azure como volumen.
    Los segmentos de código que incluyen el parámetro --secrets-mount-path no montarán un recurso compartido de archivos de Azure como volumen. El segmento de código que no incluye el parámetro --azure-file-volume-share-name no es válido.


1. Debe eliminar una imagen con la etiqueta dev/nginx:latest de un registro de contenedor de Azure denominado devregistry.
¿Qué segmento de código debería usar?
    - az acr repository delete --name devregistry --image dev/nginx:latest

    Este elemento pone a prueba los conocimientos de los candidatos sobre la publicación o eliminación de imágenes en Azure Container Registry.
    El segmento de código az acr repository delete --name devregistry --image dev/nginx:latest eliminará la imagen de un registro de contenedor. Los segmentos de código que incluyan el parámetro sufijo se deben usar si se accede al registro desde otra suscripción o se tiene permiso para acceder a imágenes, pero no para administrar el recurso del registro. Los segmentos de código que incluyen los parámetros manifest eliminan el manifiesto del artefacto, no la imagen.


1. Desarrolla una aplicación web hospedada en la característica Web Apps de Microsoft Azure App Service.
Es necesario habilitar y configurar la caché local del servicio web de Azure con 1,5 GB.
¿Qué dos segmentos de código debería usar? Cada respuesta correcta presenta parte de la solución.
    - “WEBSITE_LOCAL_CACHE_OPTION”: “Always”
    - “WEBSITE_LOCAL_CACHE_SIZEINMB”: “1500”
    
    Este elemento pone a prueba los conocimientos de los candidatos sobre la configuración de las opciones de la característica Web Apps de Azure App Service.
    Con WEBSITE_LOCAL_CACHE_OPTION = Always, se habilitará la caché local. WEBSITE_LOCAL_CACHE_SIZEINMB configurará correctamente la caché local con un tamaño de 1,5 GB. WEBSITE_LOCAL_CACHE_OPTION = Enable no es un valor válido. 1.5 no configurará 1,5 GB para la caché local.


1. Tiene previsto desarrollar una aplicación web de Azure App Service denominada app1 mediante un contenedor personalizado de Windows.
Debe cargar un certificado TLS/SSL en el código de la aplicación.
¿Qué configuración de la aplicación debería configurar? 
    - WEBSITE_LOAD_CERTIFICATES

    Este elemento pone a prueba los conocimientos de los candidatos sobre la configuración de la aplicación, lo que forma parte de la creación de Azure App Service Web Apps.
    La configuración de la aplicación WEBSITE_LOAD_CERTIFICATES hace que los certificados especificados sean accesibles para contenedores personalizados de Windows o Linux como archivos. La configuración de la aplicación WEBSITE_ROOT_CERTS_PATH es de solo lectura y no permite que los valores de huella digital separados por comas sean mencionados a los certificados y, a continuación, se carguen en el código. La configuración de la aplicación WEBSITE_AUTH_TOKEN_CONTAINER_SASURL se usa para indicar al módulo de autenticación que almacene y cargue todos los tokens cifrados en el contenedor de almacenamiento de blobs especificado. Esta configuración se usa para Azure Storage y no se puede usar para cargar certificados dentro de un contenedor personalizado de Windows.


1. Administra las ranuras de implementación de ensayo y producción de una aplicación web de Azure App Service denominada app1.
Necesita asegurarse de que no se intercambie una cadena de conexión cuando se realice el intercambio.
¿Qué configuración debe usar?
    - Configuración de ranura de implementación

    Este elemento pone a prueba los conocimientos de los candidatos sobre la implementación de código en Azure App Service, que forma parte de la creación de Azure App Service Web Apps.
    Marcar una configuración como una configuración de ranura de implementación la mantendrá pegada a esa ranura de implementación. Por ejemplo, una configuración de aplicación marcada como una configuración de ranura de implementación en app1 siempre se mantendrá con app1 y nunca se moverá a app1/staging durante un intercambio. La configuración del Centro de implementación se usa para configurar la implementación continua y la implementación manual. La identidad administrada proporciona una identidad que usan las aplicaciones al conectarse a los recursos que admiten la autenticación de Microsoft Entra ID. El escalado vertical garantizará que la aplicación web tenga derecho a obtener CPU, memoria, espacio en disco y características adicionales, como máquinas virtuales dedicadas, dominios personalizados y certificados, ranuras de ensayo y escalado automático. No se puede usar el centro de implementación, la identidad administrada y el escalado vertical para asegurarse de que no se intercambie una cadena de conexión cuando se realice el intercambio.


1. Una empresa planea implementar una solución de Microsoft Defender for Cloud.
La empresa tiene los siguientes requisitos:
Notifica cuándo no se eliminan los dominios DNS cuando se elimina una nueva aplicación de Azure Functions.
Usar alertas nativas.
Minimización de costes.
Debe seleccionar un plan de hospedaje.
¿Qué plan de hospedaje debería usar?
    - Basic

    Este elemento pone a prueba los conocimientos de los candidatos sobre la protección de Azure Functions.
    El plan Básico admite dominios personalizados y Microsoft Defender for Cloud, lo que podría alertar automáticamente sobre dominios DNS pendientes. El plan Consumo es incorrecto porque no es compatible con Microsoft Defender for Cloud. Esto podría alertar automáticamente sobre dominios DNS pendientes. El plan Premium admite dominios personalizados y Microsoft Defender for Cloud, lo que podría alertar automáticamente sobre dominios DNS pendientes. Sin embargo, esta no es la opción con el coste más bajo. El plan Gratis no admite dominios personalizados, aunque admite Microsoft Defender for Cloud, lo que podría alertar automáticamente sobre dominios DNS pendientes.


1. Usted crea una rutina por lotes mediante un desencadenador de temporizador en Azure Functions.
Debe configurar la rutina por lotes para que se ejecute cada 15 minutos, de lunes a viernes.
¿Qué segmento de código debería usar?
    - 
    ```java
    [Function(nameof(TimerTriggerCSharp))] [FixedDelayRetry(5, "00:00:10")] public static void Run([TimerTrigger("0 */15 * * * 1-5")] TimerInfo myTimer, FunctionContext context) { var log = context.GetLogger(nameof(TimerFunction)); if (myTimer.IsPastDue) { log.LogInformation("Timer is running late!"); } log.LogInformation($"C# Timer trigger function executed at: {DateTime.Now}"); }
    ```

    Este elemento pone a prueba los conocimientos de los candidatos sobre trabajar con desencadenadores de temporizador en Azure Functions.
    El segmento de código que incluye Run([TimerTrigger("0 */15 * * * * 1-5") ejecuta la función cada 15 minutos de lunes a viernes. Al segmento de código que incluye Run([TimerTrigger("*/15 * * * 0-4") le falta la segunda parte y no usa el intervalo adecuado en los días de la semana. El segmento de código que incluye Run([TimerTrigger("0 15 * * * ") se ejecuta solo una vez a las 15:00 (3 p.m.). Al segmento de código que incluye Run([TimerTrigger("* 15 * * 1-5") le falta el atributo seconds y la parte del paso ('/') en los minutos.


1. Está desarrollando una aplicación de .NET que incluye varias imágenes de contenedor. La aplicación se implementará en Azure Container Instances (ACI).
Es necesario asegurarse de que un recurso compartido de archivos de Azure se pueda asignar a cada contenedor de la aplicación.
¿Qué configuración debe usar?
    - grupo de contenedores

    Este elemento pone a prueba los conocimientos de los candidatos de la ejecución de contenedores mediante Azure Container Instances (ACI). El recurso de nivel superior de ACI es el grupo de contenedores. Un grupo de contenedores es una colección de contenedores que se programan en la misma máquina host. Puede especificar volúmenes externos para montar dentro de un grupo de contenedores. Puede asignar los volúmenes en rutas de acceso específicas dentro de los contenedores individuales en un grupo. Un pod es un grupo de uno o varios contenedores con recursos de red y almacenamiento compartidos, además de especificaciones para ejecutar los contenedores. Los pods se pueden usar en Azure Kubernetes Service, pero no en ACI. Los contenedores confidenciales de ACI se usan para garantizar la confidencialidad basada en hardware. ACI permite la implementación de instancias de contenedor en una red virtual de Azure. No se puede usar una implementación de red virtual para asignar un recurso compartido de archivos de Azure a cada contenedor en un escenario de varios contenedores.


1. Un grupo de contenedores en Azure Container Instances tiene varios contenedores.
Los contenedores deberán reiniciarse cuando el proceso ejecutado en el grupo de contenedores finalice por un error.
Debe definir la directiva de reinicio para el grupo de contenedores.
¿Qué comando de la CLI de Azure debe ejecutar?
    - az container create \ --resource-group myResourceGroup \ --name mycontainer \ --image mycontainerimage \ --restart-policy OnFailure

    Este elemento pone a prueba los conocimientos de los candidatos de la ejecución de contenedores mediante Azure Container Instances (ACI). Las directivas de reinicio configurables se pueden especificar para un grupo de contenedores en ACI. Una directiva de reinicio configurable permite especificar que los contenedores se detengan cuando se hayan completado sus procesos. Al crear un grupo de contenedores en ACI, es posible especificar una de las tres opciones de configuración de directiva de reinicio: Siempre, Nunca y OnFailure.
    Si la directiva de reinicio se menciona como OnFailure, los contenedores del grupo de contenedores solo se reiniciarán cuando se produzca un error en el proceso ejecutado en el contenedor (cuando finalice con un código de salida distinto de cero). Si la directiva de reinicio se menciona como Siempre, los contenedores del grupo de contenedores siempre se reiniciarán independientemente del éxito o error de ejecución del proceso en un contenedor. Si la directiva de reinicio se menciona como Nunca, los contenedores del grupo de contenedores solo se ejecutarán como máximo una vez.
    El comando az container restart se usa para reiniciar todos los contenedores de un grupo de contenedores, no para definir una directiva de reinicio para un grupo de contenedores.


1. Está desarrollando una aplicación de tareas en segundo plano de contenedor nativa en la nube.
Debe elegir la opción de implementación de contenedor adecuada en función de los siguientes requisitos:
Minimización del costo
Compatibilidad con la detección de servicios y la división de tráfico
Habilitación de la arquitectura de aplicaciones controladas por eventos
No requiere acceso a la API nativa de Kubernetes
¿Qué debe usar?
    - Azure Container Apps

    Este elemento pone a prueba los conocimientos de los candidatos para crear soluciones mediante Azure Container Apps. Azure Container Apps permite crear microservicios sin servidor basados en contenedores. Está optimizado para ejecutar contenedores de uso general y proporciona muchos conceptos específicos de la aplicación sobre los contenedores. Azure Spring Apps es un servicio totalmente administrado destinado a desarrolladores de Spring. Proporciona administración del ciclo de vida para ejecutar Spring Boot, Spring Cloud o cualquier otra aplicación de Spring en Azure. Azure Container Instances no admite el escalado, el equilibrio de carga, las revisiones, la escala o los entornos, además de no cumplir con los requisitos mencionados. Azure Functions es una solución de funciones como servicio (FaaS) sin servidor. Se puede usar para la ejecución de aplicaciones controladas por eventos mediante el modelo de programación de funciones. Sin embargo, no se puede usar para implementar una imagen de contenedor.


1. Está desarrollando una aplicación web Linux en Azure App Service.
Debe implementar la aplicación web en el entorno de producción en función de los siguientes requisitos:
Los cambios de la aplicación deben validarse en un entorno idéntico al entorno de producción antes de mover la aplicación al entorno de producción.
El tiempo de inactividad deberá eliminarse cuando la aplicación se implemente en el entorno de producción.
¿Qué debe usar?
    - Ranuras de implementación

    Este elemento pone a prueba los conocimientos de los candidatos sobre cuándo usar ranuras de implementación. Las ranuras de implementación son aplicaciones en directo con nombres de host únicos, lo que permite intercambiar la configuración y el contenido entre ellas. El escalado automático es una característica que permite agregar más capacidad a un entorno de hospedaje de aplicaciones de Azure Functions. Esta capacidad se puede agregar a un entorno de hospedaje individual (por ejemplo, escalar verticalmente, o bien agregar memoria o CPU) o añadiendo más hosts (escalado horizontal). El escalado se puede desencadenar en función de una programación o al infringir los umbrales definidos para determinadas métricas. Las conexiones híbridas están disponibles para consumir aplicaciones locales sin necesidad de exponerlas a Internet. La clonación de aplicaciones es un proceso para obtener una aplicación existente y copiarla en otro destino, que podría ser una aplicación nueva o una ranura de implementación, por ejemplo. Sin embargo, no es compatible con aplicaciones Linux.


1. Administra una base de datos de Azure Cosmos DB denominada database1.
Es necesario leer elementos de la base de datos sin ninguna garantía de ordenación y garantizar la máxima disponibilidad.
¿Qué nivel de coherencia debería usar?
    - Posible

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de coherencia en Azure Cosmos DB, que forma parte del desarrollo de soluciones que usan el almacenamiento de Azure Cosmos DB.
    La coherencia final tiene la coherencia más flexible y confirma cualquier operación de escritura en la principal inmediatamente. Esto proporcionará la disponibilidad más alta y la coherencia más baja. La coherencia fuerte ofrece una garantía de linearización. La linearización hace referencia a la capacidad de servir solicitudes simultáneamente. Se garantiza que los usuarios siempre leerán la escritura confirmada más reciente. Una coherencia fuerte sufrirá de disponibilidad reducida. La coherencia de obsolescencia limitada no proporcionará la máxima disponibilidad. Cuando un cliente realiza operaciones de lectura dentro de una región que acepta escrituras, las garantías proporcionadas por la coherencia de obsolescencia limitada y la coherencia fuerte serán idénticas. La coherencia de la sesión garantizará que en una sesión de usuario todas las operaciones de lectura y escritura sean coherentes. Dado que la aplicación no requiere garantía de coherencia, este nivel de coherencia no es adecuado.


1. Administra un contenedor de Azure Cosmos DB denominado container1.
Debe usar el método ReadItemAsync para leer un elemento del servicio Azure Cosmos.
¿Qué dos parámetros deberá proporcionar? Cada respuesta correcta presenta parte de la solución.
    - partitionKey
    - id

    Este elemento pone a prueba los conocimientos de los candidatos sobre cómo establecer la clave de partición, lo que forma parte del desarrollo de soluciones de Azure Cosmos DB.
    El método ReadItemAsync de la clase de contenedor del SDK de .NET para Azure Cosmos DB tiene dos parámetros obligatorios: partitionKey e itemId. El parámetro consistencyLevel forma parte del parámetro requestOptions opcional del ReadItemAsync.
    Los parámetros eTag y sessionToken forman parte del parámetro requestOptions opcional del método ReadItemAsync.


1. Tiene una aplicación que escribe datos en Azure Cosmos DB.
La aplicación debe ofrecer lecturas monotónicas, sin ninguna garantía de que el valor leído sea el último valor escrito.
Es necesario configurar el nivel de coherencia.
¿Qué nivel de coherencia debería usar?
    - session

    Este elemento pone a prueba los conocimientos de los candidatos sobre los niveles de coherencia de Azure Cosmos DB.
    La coherencia de la sesión ofrece todas las garantías enumeradas. Proporciona latencias de escritura, disponibilidad y rendimiento de lectura comparables a los de la coherencia posible. También proporciona garantías de coherencia que satisfacen las necesidades de las aplicaciones escritas para funcionar en el contexto de usuarios. La coherencia fuerte tiene lecturas garantizadas para devolver la versión confirmada más reciente de un elemento. Un cliente nunca ve una escritura no confirmada ni parcial. Se garantiza que los usuarios leerán la escritura confirmada más reciente. Tiene la latencia de escritura más alta y el rendimiento de lectura más bajo de todos los niveles de coherencia. En la obsolescencia limitada se garantiza que las lecturas respetan la garantía de prefijo coherente. Se debe usar cuando se necesiten latencias de escritura bajas, pero se requiere una garantía total de orden global. En la coherencia final, no hay ninguna garantía de ordenación para las lecturas. En ausencia de escrituras adicionales, las réplicas terminarán por converger. Es la forma más débil de coherencia, ya que un cliente podría leer valores que sean más antiguos que los que había leído antes. La coherencia final es adecuada cuando la aplicación no requiere ninguna garantía de ordenación.


1. Tiene blobs en Azure Blob Storage. Los blobs almacenan imágenes.
Es necesario registrar la información sobre la ubicación y las condiciones meteorológicas desde el momento en que se tomaron las imágenes. Asegúrese de poder usar hasta 2000 caracteres al grabar la información.
¿Qué tiene que hacer?
    - Use encabezados de metadatos definidos con una solicitud PUT

    Este elemento pone a prueba los conocimientos de los candidatos sobre la estructuración de datos para Blob Storage.
    Los metadatos son la manera adecuada de definir este tipo de datos, lo que permite realizar modificaciones independientes y admitir hasta 8 KB de tamaño total. El verbo HTTP para definir metadatos es PUT y este es el formato correcto para definir valores de metadatos. El tamaño máximo de un nombre de blob es de 1024 caracteres. Además, esto no es un enfoque óptimo porque los metadatos se pueden obtener y establecer de forma independiente, manteniendo el mismo nombre de archivo. Los metadatos son la manera adecuada de definir este tipo de datos, lo que permite realizar modificaciones independientes y admitir hasta 8 KB de tamaño total. Pero el verbo HTTP para definir metadatos es PUT, no POST. La combinación de ubicaciones y tipos meteorológicos puede ser potencialmente ilimitada, y los nombres de contenedor están limitados a 63 caracteres.


1. Debe descargar el contenido del blob en una matriz de bytes mediante una operación que se recupera automáticamente frente a errores transitorios.
¿Qué instrucción de código debería usar?
    - 
    ```java
    byte[] data; BlobClientOptions options = new BlobClientOptions(); options.Retry.MaxRetries = 10; options.Retry.Delay = TimeSpan.FromSeconds(20); BlobClient client = new BlobClient(new Uri("https://mystorageaccount.blob.core.windows.net/containers/blob.txt"), options); Response response = client.DownloadContent(); data = response.Value.Content.ToArray();
    ```

    Este elemento prueba los conocimientos de los candidatos sobre la implementación de directivas de almacenamiento.
    El segmento de código que incluye options.Retry.MaxRetries = 10; y options.Retry.Delay = TimeSpan.FromSeconds(20); define la estrategia de reintentos y descarga el contenido en los datos de la variable. Los segmentos de código que no incluyen estos parámetros no definen la estrategia de reintento.


1. 
    -






